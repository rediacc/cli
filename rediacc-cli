#!/usr/bin/env python3
"""
Rediacc CLI - Complete command-line interface for Rediacc Middleware API
Includes all functionality from both CLI and test suite with enhanced queue support
"""
import argparse
import base64
import getpass
import hashlib
import json
import os
import sys
import urllib.request
import urllib.parse
import urllib.error
from typing import Dict, Any, Optional, List, Union

# Configuration
BASE_URL = os.environ.get('REDIACC_API_URL', 'http://localhost:8080')
API_PREFIX = '/api/StoredProcedure'
CONFIG_DIR = os.path.expanduser('~/.rediacc')
CONFIG_FILE = os.path.join(CONFIG_DIR, 'config.json')
REQUEST_TIMEOUT = 30
TEST_ACTIVATION_CODE = '111111'

# Color codes for terminal output
COLORS = {
    'HEADER': '\033[95m', 'BLUE': '\033[94m', 'GREEN': '\033[92m',
    'YELLOW': '\033[93m', 'RED': '\033[91m', 'ENDC': '\033[0m', 'BOLD': '\033[1m',
}

def colorize(text, color):
    """Add color to terminal output if supported"""
    return f"{COLORS.get(color, '')}{text}{COLORS['ENDC']}" if sys.stdout.isatty() else text

# Available bash functions for queuing
QUEUE_FUNCTIONS = {
    # System setup functions
    'os_setup': {
        'description': 'Setup operating system with required tools and configurations',
        'params': {
            'datastore_size': {'type': 'string', 'default': '95%', 'help': 'Datastore size (e.g., 95%, 100G)'},
            'source': {'type': 'string', 'default': 'apt-repo', 'help': 'Package source'}
        }
    },
    'hello': {
        'description': 'Simple test function that prints hello from hostname',
        'params': {}
    },
    'uninstall': {
        'description': 'Cleanup and uninstall system components',
        'params': {}
    },
    
    # Repository management functions
    'repo_new': {
        'description': 'Create a new repository',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name (no numbers)'},
            'size': {'type': 'string', 'required': True, 'help': 'Repository size (e.g., 10G)'}
        }
    },
    'repo_mount': {
        'description': 'Mount repository filesystems',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'from': {'type': 'string', 'help': 'Remote machine to mount from'}
        }
    },
    'repo_unmount': {
        'description': 'Unmount repository filesystems',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'from': {'type': 'string', 'help': 'Remote machine to unmount from'}
        }
    },
    'repo_up': {
        'description': 'Start repository services using Rediaccfile',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'option': {'type': 'string', 'help': 'Options (e.g., prep-only)'}
        }
    },
    'repo_down': {
        'description': 'Stop repository services',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'}
        }
    },
    'repo_resize': {
        'description': 'Resize repository storage',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name'},
            'size': {'type': 'string', 'required': True, 'help': 'New size (e.g., 20G)'}
        }
    },
    'repo_rm': {
        'description': 'Delete repository',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name'}
        }
    },
    'repo_plugin': {
        'description': 'Activate repository plugins',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'plugin': {'type': 'string', 'required': True, 'help': 'Plugin name(s), comma-separated'}
        }
    },
    'repo_plugout': {
        'description': 'Deactivate repository plugins',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'plugin': {'type': 'string', 'required': True, 'help': 'Plugin name(s), comma-separated'}
        }
    },
    'repo_ownership': {
        'description': 'Change repository ownership',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name'},
            'from': {'type': 'string', 'required': True, 'help': 'Current owner'},
            'to': {'type': 'string', 'help': 'New owner (default: universal user)'}
        }
    },
    'repo_list': {
        'description': 'List repositories',
        'params': {
            'kind': {'type': 'string', 'default': 'repo', 'help': 'Type to list'},
            'format': {'type': 'string', 'help': 'Output format (json)'}
        }
    },
    
    # Backup functions
    'repo_push': {
        'description': 'Push repository to remote storage',
        'params': {
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'},
            'to': {'type': 'string', 'help': 'Destination machine/storage'},
            'option': {'type': 'string', 'help': 'Options (e.g., no-suffix, override)'}
        }
    },
    'repo_pull': {
        'description': 'Pull repository from remote storage',
        'params': {
            'from': {'type': 'string', 'required': True, 'help': 'Source machine/storage'},
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name(s), comma-separated'}
        }
    },
    
    # Socket mapping
    'map_socket': {
        'description': 'Map socket from remote machine',
        'params': {
            'machine': {'type': 'string', 'required': True, 'help': 'Machine name'},
            'repo': {'type': 'string', 'required': True, 'help': 'Repository name'},
            'plugin': {'type': 'string', 'required': True, 'help': 'Plugin name'}
        }
    }
}

# Command and API endpoint configuration
CMD_CONFIG = {
    # Authentication commands
    'login': {
        'auth_required': False,
        'endpoint': 'CreateAuthenticationRequest',
        'auth_type': 'credentials',
        'success_msg': 'Successfully logged in as {email}'
    },
    'logout': {
        'auth_required': True,
        'endpoint': 'DeleteUserRequest',
        'auth_type': 'token',
        'success_msg': 'Successfully logged out'
    },
    
    # Create commands
    'create': {
        'company': {
            'endpoint': 'CreateNewCompany',
            'auth_type': 'credentials',
            'params': lambda args: {
                'companyName': args.name,
                'subscriptionPlan': args.plan or 'ELITE'
            },
            'success_msg': 'Successfully created company: {name}'
        },
        'user': {
            'endpoint': 'CreateNewUser',
            'params': lambda args: {
                'newUserEmail': args.email,
                'newUserHash': pwd_hash_hex(args.password)
            },
            'success_msg': 'Successfully created user: {email}'
        },
        'team': {
            'endpoint': 'CreateTeam',
            'params': lambda args: {
                'teamName': args.name,
                'teamVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created team: {name}'
        },
        'region': {
            'endpoint': 'CreateRegion',
            'params': lambda args: {
                'regionName': args.name,
                'regionVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created region: {name}'
        },
        'bridge': {
            'endpoint': 'CreateBridge',
            'params': lambda args: {
                'regionName': args.region,
                'bridgeName': args.name,
                'bridgeVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created bridge: {name} in region {region}'
        },
        'machine': {
            'endpoint': 'CreateMachine',
            'params': lambda args: {
                'teamName': args.team,
                'bridgeName': args.bridge,
                'machineName': args.name,
                'machineVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created machine: {name} for team {team}'
        },
        'repository': {
            'endpoint': 'CreateRepository',
            'params': lambda args: {
                'teamName': args.team,
                'repoName': args.name,
                'repoVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created repository: {name} for team {team}'
        },
        'storage': {
            'endpoint': 'CreateStorage',
            'params': lambda args: {
                'teamName': args.team,
                'storageName': args.name,
                'storageVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created storage: {name} for team {team}'
        },
        'schedule': {
            'endpoint': 'CreateSchedule',
            'params': lambda args: {
                'teamName': args.team,
                'scheduleName': args.name,
                'scheduleVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created schedule: {name} for team {team}'
        },
        'queue-item': {
            'endpoint': 'CreateQueueItem',
            'params': lambda args: {
                'teamName': args.team,
                'machineName': args.machine,
                'queueVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully created queue item for machine {machine}'
        }
    },
    
    # List commands
    'list': {
        'teams': {
            'endpoint': 'GetCompanyTeams',
            'params': lambda args: {}
        },
        'regions': {
            'endpoint': 'GetCompanyRegions',
            'params': lambda args: {}
        },
        'bridges': {
            'endpoint': 'GetRegionBridges',
            'params': lambda args: {'regionName': args.region}
        },
        'machines': {
            'endpoint': 'GetTeamMachines',
            'params': lambda args: {'teamName': args.team}
        },
        'repositories': {
            'endpoint': 'GetTeamRepositories',
            'params': lambda args: {'teamName': args.team}
        },
        'storages': {
            'endpoint': 'GetTeamStorages',
            'params': lambda args: {'teamName': args.team}
        },
        'schedules': {
            'endpoint': 'GetTeamSchedules',
            'params': lambda args: {'teamName': args.team}
        },
        'users': {
            'endpoint': 'GetCompanyUsers',
            'params': lambda args: {}
        },
        'sessions': {
            'endpoint': 'GetUserRequests',
            'params': lambda args: {}
        },
        'queue-items': {
            'endpoint': 'GetTeamQueueItems',
            'params': lambda args: {'teamName': args.team}
        },
        'resource-limits': {
            'endpoint': 'GetCompanyResourceLimits',
            'params': lambda args: {}
        },
        'subscription': {
            'endpoint': 'GetSubscriptionDetails',
            'params': lambda args: {}
        }
    },
    
    # Remove commands
    'rm': {
        'team': {
            'endpoint': 'DeleteTeam',
            'params': lambda args: {'teamName': args.name},
            'confirm_msg': "Are you sure you want to delete team '{name}'? This will remove all resources in the team.",
            'success_msg': 'Successfully deleted team: {name}'
        },
        'machine': {
            'endpoint': 'DeleteMachine',
            'params': lambda args: {'teamName': args.team, 'machineName': args.name},
            'confirm_msg': "Are you sure you want to delete machine '{name}' from team '{team}'?",
            'success_msg': 'Successfully deleted machine: {name}'
        },
        'bridge': {
            'endpoint': 'DeleteBridge',
            'params': lambda args: {'regionName': args.region, 'bridgeName': args.name},
            'confirm_msg': "Are you sure you want to delete bridge '{name}' from region '{region}'?",
            'success_msg': 'Successfully deleted bridge: {name}'
        },
        'region': {
            'endpoint': 'DeleteRegion',
            'params': lambda args: {'regionName': args.name},
            'confirm_msg': "Are you sure you want to delete region '{name}'? This will remove all bridges in the region.",
            'success_msg': 'Successfully deleted region: {name}'
        },
        'repository': {
            'endpoint': 'DeleteRepository',
            'params': lambda args: {'teamName': args.team, 'repoName': args.name},
            'confirm_msg': "Are you sure you want to delete repository '{name}' from team '{team}'?",
            'success_msg': 'Successfully deleted repository: {name}'
        },
        'storage': {
            'endpoint': 'DeleteStorage',
            'params': lambda args: {'teamName': args.team, 'storageName': args.name},
            'confirm_msg': "Are you sure you want to delete storage '{name}' from team '{team}'?",
            'success_msg': 'Successfully deleted storage: {name}'
        },
        'schedule': {
            'endpoint': 'DeleteSchedule',
            'params': lambda args: {'teamName': args.team, 'scheduleName': args.name},
            'confirm_msg': "Are you sure you want to delete schedule '{name}' from team '{team}'?",
            'success_msg': 'Successfully deleted schedule: {name}'
        },
        'queue-item': {
            'endpoint': 'DeleteQueueItem',
            'params': lambda args: {'taskId': args.task_id},
            'confirm_msg': "Are you sure you want to delete queue item '{task_id}'?",
            'success_msg': 'Successfully deleted queue item: {task_id}'
        }
    },
    
    # Vault commands
    'vault': {
        'set': {
            'endpoints': {
                'team': 'UpdateTeamVault',
                'machine': 'UpdateMachineVault',
                'region': 'UpdateRegionVault',
                'bridge': 'UpdateBridgeVault',
                'company': 'UpdateCompanyVault',
                'repository': 'UpdateRepositoryVault',
                'storage': 'UpdateStorageVault',
                'schedule': 'UpdateScheduleVault'
            },
            'params': lambda args: get_vault_set_params(args),
            'success_msg': 'Successfully updated {resource_type} vault'
        }
    },

    # Permission commands
    'permission': {
        'create-group': {
            'endpoint': 'CreatePermissionGroup',
            'params': lambda args: {'permissionGroupName': args.name},
            'success_msg': 'Successfully created permission group: {name}'
        },
        'delete-group': {
            'endpoint': 'DeletePermissionGroup',
            'params': lambda args: {'permissionGroupName': args.name},
            'confirm_msg': "Are you sure you want to delete permission group '{name}'?",
            'success_msg': 'Successfully deleted permission group: {name}'
        },
        'add': {
            'endpoint': 'CreatePermissionInGroup',
            'params': lambda args: {
                'permissionGroupName': args.group, 
                'permissionName': args.name
            },
            'success_msg': 'Successfully added permission: {name} to group {group}'
        },
        'remove': {
            'endpoint': 'DeletePermissionFromGroup',
            'params': lambda args: {
                'permissionGroupName': args.group, 
                'permissionName': args.name
            },
            'confirm_msg': "Are you sure you want to remove permission '{name}' from group '{group}'?",
            'success_msg': 'Successfully removed permission: {name} from group {group}'
        },
        'assign': {
            'endpoint': 'UpdateUserAssignedPermissions',
            'params': lambda args: {
                'userEmail': args.email, 
                'permissionGroupName': args.group
            },
            'success_msg': 'Successfully assigned permission group {group} to user {email}'
        },
        'list-groups': {
            'endpoint': 'GetCompanyPermissionGroups',
            'params': lambda args: {}
        },
        'list-group': {
            'endpoint': 'GetPermissionGroupDetails',
            'params': lambda args: {'permissionGroupName': args.name}
        }
    },
    
    # User commands
    'user': {
        'activate': {
            'auth_required': False,
            'endpoint': 'ActivateUserAccount',
            'params': lambda args: {
                'userEmail': args.email,
                'activationCode': args.code or TEST_ACTIVATION_CODE
            },
            'success_msg': 'Successfully activated user: {email}'
        },
        'deactivate': {
            'endpoint': 'UpdateUserToDeactivated',
            'params': lambda args: {'userEmail': args.email},
            'confirm_msg': "Are you sure you want to deactivate user '{email}'?",
            'success_msg': 'Successfully deactivated user: {email}'
        },
        'update-email': {
            'endpoint': 'UpdateUserEmail',
            'params': lambda args: {
                'currentUserEmail': args.current_email,
                'newUserEmail': args.new_email
            },
            'success_msg': 'Successfully updated user email: {current_email} → {new_email}'
        },
        'update-password': {
            'endpoint': 'UpdateUserPassword',
            'params': lambda args: {
                'userNewPass': pwd_hash_hex(args.new_password)
            },
            'success_msg': 'Successfully updated user password'
        }
    },
    
    # Team membership commands
    'team-member': {
        'add': {
            'endpoint': 'CreateTeamMembership',
            'params': lambda args: {
                'teamName': args.team,
                'newUserEmail': args.email
            },
            'success_msg': 'Successfully added {email} to team {team}'
        },
        'remove': {
            'endpoint': 'DeleteUserFromTeam',
            'params': lambda args: {
                'teamName': args.team,
                'removeUserEmail': args.email
            },
            'confirm_msg': "Are you sure you want to remove '{email}' from team '{team}'?",
            'success_msg': 'Successfully removed {email} from team {team}'
        },
        'list': {
            'endpoint': 'GetTeamMembers',
            'params': lambda args: {'teamName': args.team}
        }
    },
    
    # Queue commands
    'queue': {
        'get-next': {
            'endpoint': 'GetQueueItemsNext',
            'params': lambda args: {
                'machineName': args.machine,
                'itemCount': args.count or 5
            }
        },
        'update-response': {
            'endpoint': 'UpdateQueueItemResponse',
            'params': lambda args: {
                'taskId': args.task_id,
                'responseVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully updated queue item response: {task_id}'
        },
        'complete': {
            'endpoint': 'UpdateQueueItemToCompleted',
            'params': lambda args: {
                'taskId': args.task_id,
                'finalVault': get_vault_data(args) or '{}'
            },
            'success_msg': 'Successfully completed queue item: {task_id}'
        }
    }
}

# Command-line argument definitions
ARG_DEFS = {
    'login': [
        {'name': '--email', 'help': 'User email address'},
        {'name': '--password', 'help': 'User password'},
        {'name': '--session-name', 'help': 'Name for this session'}
    ],
    'logout': [],
    
    'create': {
        'company': [
            {'name': 'name', 'help': 'Company name'},
            {'name': '--email', 'help': 'Admin email address'},
            {'name': '--password', 'help': 'Admin password'},
            {'name': '--plan', 'help': 'Subscription plan', 'choices': ['FREE', 'BASIC', 'PRO', 'ELITE']}
        ],
        'user': [
            {'name': 'email', 'help': 'User email address'},
            {'name': '--password', 'help': 'User password'}
        ],
        'team': [
            {'name': 'name', 'help': 'Team name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'region': [
            {'name': 'name', 'help': 'Region name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'bridge': [
            {'name': 'region', 'help': 'Region name'},
            {'name': 'name', 'help': 'Bridge name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'machine': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'bridge', 'help': 'Bridge name'},
            {'name': 'name', 'help': 'Machine name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'repository': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Repository name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'storage': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Storage name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'schedule': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Schedule name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'queue-item': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'machine', 'help': 'Machine name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ]
    },
    
    'list': {
        'teams': [],
        'regions': [],
        'users': [],
        'sessions': [],
        'resource-limits': [],
        'subscription': [],
        'bridges': [{'name': 'region', 'help': 'Region name'}],
        'machines': [{'name': 'team', 'help': 'Team name'}],
        'repositories': [{'name': 'team', 'help': 'Team name'}],
        'storages': [{'name': 'team', 'help': 'Team name'}],
        'schedules': [{'name': 'team', 'help': 'Team name'}],
        'queue-items': [{'name': 'team', 'help': 'Team name'}]
    },
    
    'inspect': {
        'team': [{'name': 'name', 'help': 'Team name'}],
        'machine': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Machine name'}
        ]
    },
    
    'update': {
        'team': [
            {'name': 'name', 'help': 'Team name'},
            {'name': '--new-name', 'help': 'New team name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'},
            {'name': '--vault-version', 'type': int, 'help': 'Vault version'}
        ],
        'region': [
            {'name': 'name', 'help': 'Region name'},
            {'name': '--new-name', 'help': 'New region name'}
        ],
        'bridge': [
            {'name': 'region', 'help': 'Region name'},
            {'name': 'name', 'help': 'Bridge name'},
            {'name': '--new-name', 'help': 'New bridge name'}
        ],
        'machine': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Machine name'},
            {'name': '--new-name', 'help': 'New machine name'},
            {'name': '--new-bridge', 'help': 'New bridge name'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'},
            {'name': '--vault-version', 'type': int, 'help': 'Vault version'}
        ],
        'repository': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Repository name'},
            {'name': '--new-name', 'help': 'New repository name'}
        ],
        'storage': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Storage name'},
            {'name': '--new-name', 'help': 'New storage name'}
        ],
        'schedule': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Schedule name'},
            {'name': '--new-name', 'help': 'New schedule name'}
        ]
    },
    
    'rm': {
        'team': [
            {'name': 'name', 'help': 'Team name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'machine': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Machine name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'bridge': [
            {'name': 'region', 'help': 'Region name'},
            {'name': 'name', 'help': 'Bridge name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'region': [
            {'name': 'name', 'help': 'Region name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'repository': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Repository name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'storage': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Storage name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'schedule': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'name', 'help': 'Schedule name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'queue-item': [
            {'name': 'task_id', 'help': 'Task ID'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ]
    },
    
    'vault': {
        'set': [
            {'name': 'resource_type', 'help': 'Resource type',
             'choices': ['team', 'machine', 'region', 'bridge', 'company', 'repository', 'storage', 'schedule']},
            {'name': 'name', 'help': 'Resource name'},
            {'name': 'file', 'nargs': '?', 'help': 'File containing JSON vault data (or - for stdin)'},
            {'name': '--team', 'help': 'Team name (for machine, repository, storage, schedule)'},
            {'name': '--region', 'help': 'Region name (for bridge)'},
            {'name': '--vault-version', 'type': int, 'help': 'Vault version'}
        ]
    },
    
    # Permission command arguments
    'permission': {
        'create-group': [
            {'name': 'name', 'help': 'Permission group name'}
        ],
        'delete-group': [
            {'name': 'name', 'help': 'Permission group name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'add': [
            {'name': 'group', 'help': 'Permission group name'},
            {'name': 'name', 'help': 'Permission name'}
        ],
        'remove': [
            {'name': 'group', 'help': 'Permission group name'},
            {'name': 'name', 'help': 'Permission name'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'assign': [
            {'name': 'email', 'help': 'User email address'},
            {'name': 'group', 'help': 'Permission group name'}
        ],
        'list-groups': [],
        'list-group': [
            {'name': 'name', 'help': 'Permission group name'}
        ]
    },
    
    # User command arguments
    'user': {
        'activate': [
            {'name': 'email', 'help': 'User email address'},
            {'name': '--code', 'help': f'Activation code (default: {TEST_ACTIVATION_CODE})'}
        ],
        'deactivate': [
            {'name': 'email', 'help': 'User email address'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'update-email': [
            {'name': 'current_email', 'help': 'Current user email'},
            {'name': 'new_email', 'help': 'New user email'}
        ],
        'update-password': [
            {'name': '--new-password', 'help': 'New password'}
        ]
    },
    
    # Team member command arguments
    'team-member': {
        'add': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'email', 'help': 'User email address'}
        ],
        'remove': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'email', 'help': 'User email address'},
            {'name': '--force', 'action': 'store_true', 'help': 'Skip confirmation'}
        ],
        'list': [
            {'name': 'team', 'help': 'Team name'}
        ]
    },
    
    # Queue command arguments with enhanced functionality
    'queue': {
        'get-next': [
            {'name': 'machine', 'help': 'Machine name'},
            {'name': '--count', 'type': int, 'help': 'Number of items to retrieve (default: 5)'}
        ],
        'update-response': [
            {'name': 'task_id', 'help': 'Task ID'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'complete': [
            {'name': 'task_id', 'help': 'Task ID'},
            {'name': '--vault', 'help': 'JSON vault data'},
            {'name': '--vault-file', 'help': 'File containing JSON vault data'}
        ],
        'add': [
            {'name': 'team', 'help': 'Team name'},
            {'name': 'machine', 'help': 'Machine name'},
            {'name': 'function', 'help': 'Function to execute', 'choices': list(QUEUE_FUNCTIONS.keys())},
            {'name': '--description', 'help': 'Queue item description'},
            {'name': '--priority', 'type': int, 'default': 5, 'help': 'Priority (1-10, default: 5)'}
        ],
        'list-functions': []
    }
}

class ConfigManager:
    """Manages configuration and authentication state"""
    def __init__(self):
        self.config = self._load_config()
    
    def _load_config(self):
        """Load configuration from file"""
        if not os.path.exists(CONFIG_FILE):
            return {}
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}
    
    def save_config(self):
        """Save current configuration to file"""
        os.makedirs(CONFIG_DIR, exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def set_auth(self, email, token, company=None):
        """Update authentication information"""
        self.config.update({'email': email, 'token': token, 'company': company})
        self.save_config()
    
    def clear_auth(self):
        """Clear authentication information"""
        for key in ['email', 'token', 'company']:
            self.config.pop(key, None)
        self.save_config()
    
    def is_authenticated(self):
        """Check if user is authenticated"""
        return bool(self.config.get('token'))

class APIClient:
    """Client for interacting with the Rediacc Middleware API"""
    def __init__(self, config=None, config_manager=None):
        self.config = config or {}
        self.config_manager = config_manager
        self.base_headers = {"Content-Type": "application/json"}
    
    def request(self, endpoint, data=None, headers=None):
        """Make an API request to the middleware service"""
        url = f"{BASE_URL}{API_PREFIX}/{endpoint}"
        
        # Merge headers
        merged_headers = self.base_headers.copy()
        if headers:
            merged_headers.update(headers)
        
        # Prepare the request
        request_data = json.dumps(data or {}).encode('utf-8')
        req = urllib.request.Request(
            url,
            data=request_data,
            headers=merged_headers,
            method='POST'
        )
        
        try:
            # Make the request with timeout
            with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as response:
                response_data = response.read().decode('utf-8')
                
                if response.status != 200:
                    return {"error": f"API Error: {response.status} - {response_data}", 
                            "status_code": response.status}
                
                result = json.loads(response_data)
                
                # Check for actual failure (failure != 0)
                if result.get('failure') and result.get('failure') != 0:
                    errors = result.get('errors', [])
                    if errors and len(errors) > 0:
                        error_msg = f"API Error: {'; '.join(errors)}"
                    else:
                        error_msg = f"API Error: {result.get('message', 'Request failed')}"
                    return {"error": error_msg, "status_code": 400}
                
                return result
                
        except urllib.error.HTTPError as e:
            error_body = e.read().decode('utf-8') if e.fp else str(e)
            return {"error": f"API Error: {e.code} - {error_body}", "status_code": e.code}
        except urllib.error.URLError as e:
            return {"error": f"Connection error: {str(e)}", "status_code": 500}
        except Exception as e:
            return {"error": f"Request error: {str(e)}", "status_code": 500}
    
    def auth_request(self, endpoint, email, pwd_hash, data=None):
        """Make an authenticated request with user credentials"""
        return self.request(endpoint, data, {
            "Rediacc-UserEmail": email,
            "Rediacc-UserHash": pwd_hash
        })
    
    def token_request(self, endpoint, data=None):
        """Make a request authenticated with a token"""
        if not self.config.get('token'):
            return {"error": "Not authenticated. Please login first.", "status_code": 401}
        
        response = self.request(endpoint, data, {
            "Rediacc-RequestToken": self.config['token']
        })
        
        # Update token if a new one is provided (token chain mechanism)
        if response and not response.get('error'):
            tables = response.get('tables', [])
            if tables and tables[0].get('data'):
                new_token = tables[0]['data'][0].get('nextRequestCredential')
                if new_token and self.config_manager:
                    self.config['token'] = new_token
                    self.config_manager.config['token'] = new_token
                    self.config_manager.save_config()
        
        return response

# Output format handler
def format_output(data, format_type, message=None, error=None):
    """Format output based on the specified format type"""
    if format_type == 'json':
        output = {
            'success': error is None,
            'data': data
        }
        if message:
            output['message'] = message
        if error:
            output['error'] = error
        return json.dumps(output, indent=2)
    else:
        # Text format (default)
        if error:
            return colorize(f"Error: {error}", 'RED')
        elif data:
            return data
        elif message:
            return colorize(message, 'GREEN')
        else:
            return "No data available"

# Utility functions
def pwd_hash(pwd):
    """Generate a base64 password hash for authentication"""
    return base64.b64encode(hashlib.sha256(pwd.encode()).digest()).decode()

def pwd_hash_hex(pwd):
    """Generate a hexadecimal password hash for user creation/updates"""
    return "0x" + hashlib.sha256(pwd.encode()).digest().hex()

def extract_table_data(response, table_index=0):
    """Extract data from API response tables"""
    if not response or 'tables' not in response or len(response['tables']) <= table_index:
        return []
    return response['tables'][table_index].get('data', [])

def get_vault_data(args):
    """Get vault data from arguments"""
    if hasattr(args, 'vault_file') and args.vault_file:
        try:
            if args.vault_file == '-':
                return json.dumps(json.loads(sys.stdin.read()))
            with open(args.vault_file, 'r') as f:
                return json.dumps(json.load(f))
        except (IOError, json.JSONDecodeError) as e:
            print(colorize(f"Warning: Could not load vault data: {e}", 'YELLOW'))
            return '{}'
    return args.vault if hasattr(args, 'vault') and args.vault else '{}'

def get_vault_set_params(args):
    """Generate params for vault set commands"""
    # Load vault data
    vault_data = None
    if args.file and args.file != '-':
        try:
            with open(args.file, 'r') as f:
                vault_data = f.read()
        except IOError:
            print(colorize(f"Error: Could not read file: {args.file}", 'RED'))
            return None
    else:
        # Read from stdin
        print("Enter JSON vault data (press Ctrl+D when finished):")
        vault_data = sys.stdin.read()
    
    # Validate JSON
    try:
        json.loads(vault_data)
    except json.JSONDecodeError as e:
        print(colorize(f"Error: Invalid JSON: {str(e)}", 'RED'))
        return None
    
    # Base params
    params = {'vaultVersion': args.vault_version or 1}
    
    # Resource-specific params
    if args.resource_type == 'team':
        params.update({'teamName': args.name, 'teamVault': vault_data})
    elif args.resource_type == 'machine':
        params.update({'teamName': args.team, 'machineName': args.name, 'machineVault': vault_data})
    elif args.resource_type == 'region':
        params.update({'regionName': args.name, 'regionVault': vault_data})
    elif args.resource_type == 'bridge':
        params.update({'regionName': args.region, 'bridgeName': args.name, 'bridgeVault': vault_data})
    elif args.resource_type == 'company':
        params['companyVault'] = vault_data
    elif args.resource_type == 'repository':
        params.update({'teamName': args.team, 'repoName': args.name, 'repoVault': vault_data})
    elif args.resource_type == 'storage':
        params.update({'teamName': args.team, 'storageName': args.name, 'storageVault': vault_data})
    elif args.resource_type == 'schedule':
        params.update({'teamName': args.team, 'scheduleName': args.name, 'scheduleVault': vault_data})
    
    return params

def camel_to_title(name):
    """Convert camelCase or PascalCase to Title Case"""
    # Handle special cases
    special_cases = {
        'vaultVersion': 'Vault Version', 'vaultContent': 'Vault Content',
        'memberCount': 'Members', 'machineCount': 'Machines',
        'bridgeCount': 'Bridges', 'repoCount': 'Repos',
        'storageCount': 'Storage', 'scheduleCount': 'Schedules',
        'queueCount': 'Queue Items', 'teamName': 'Team',
        'regionName': 'Region', 'bridgeName': 'Bridge',
        'machineName': 'Machine', 'repoName': 'Repository',
        'storageName': 'Storage', 'scheduleName': 'Schedule',
        'userEmail': 'Email', 'companyName': 'Company',
        'hasAccess': 'Access', 'isMember': 'Member',
        'activated': 'Active', 'taskId': 'Task ID',
        'itemCount': 'Count', 'newUserEmail': 'Email',
        'permissionGroupName': 'Permission Group',
        'permissionName': 'Permission', 'subscriptionPlan': 'Plan',
        'maxTeams': 'Max Teams', 'maxRegions': 'Max Regions',
        'maxMachines': 'Max Machines', 'maxStorage': 'Max Storage',
        'sessionName': 'Session', 'createdAt': 'Created',
        'updatedAt': 'Updated', 'lastActive': 'Last Active'
    }
    
    if name in special_cases:
        return special_cases[name]
    
    # Insert spaces before capital letters
    result = name[0].upper()
    for char in name[1:]:
        if char.isupper():
            result += ' ' + char
        else:
            result += char
    
    return result

def format_table(headers, rows):
    """Format data as a table for display"""
    if not rows:
        return "No items found"
    
    # Calculate column widths
    widths = [len(h) for h in headers]
    for row in rows:
        for i, cell in enumerate(row):
            widths[i] = max(widths[i], len(str(cell)))
    
    # Format the headers and rows
    header_line = '  '.join(h.ljust(w) for h, w in zip(headers, widths))
    separator = '-' * len(header_line)
    formatted_rows = [
        '  '.join(str(cell).ljust(w) for cell, w in zip(row, widths))
        for row in rows
    ]
    
    return '\n'.join([header_line, separator] + formatted_rows)

def table_to_dict(headers, rows):
    """Convert table data to a list of dictionaries for JSON output"""
    result = []
    for row in rows:
        item = {}
        for i, header in enumerate(headers):
            if i < len(row):
                item[header] = row[i]
        result.append(item)
    return result

def format_dynamic_tables(response, output_format='text', skip_fields=None):
    """Format all tables from response dynamically, skipping table index 0"""
    if not response or 'tables' not in response:
        return format_output("No data available", output_format)
    
    tables = response.get('tables', [])
    if len(tables) <= 1:
        return format_output("No records found", output_format)
    
    # Fields to skip in output
    if skip_fields is None:
        skip_fields = ['vaultContent', 'nextRequestCredential', 'vaultVersion', 'newUserHash']
    
    if output_format == 'json':
        # For JSON output, convert all tables to lists of dictionaries
        result = []
        for table_idx in range(1, len(tables)):
            table = tables[table_idx]
            data = table.get('data', [])
            
            if not data:
                continue
                
            # Process each record, removing fields we want to skip
            processed_data = []
            for record in data:
                processed_record = {k: v for k, v in record.items() if k not in skip_fields}
                processed_data.append(processed_record)
            
            result.extend(processed_data)
        
        return format_output(result, output_format)
    else:
        # For text output, format as before
        output_parts = []
        
        # Process each table (skip index 0 which contains credentials)
        for table_idx in range(1, len(tables)):
            table = tables[table_idx]
            data = table.get('data', [])
            
            if not data:
                continue
            
            # Get all unique keys from all records
            all_keys = set()
            for record in data:
                all_keys.update(record.keys())
            
            # Remove fields we want to skip
            display_keys = [k for k in sorted(all_keys) if k not in skip_fields]
            
            if not display_keys:
                continue
            
            # Create headers and rows
            headers = [camel_to_title(key) for key in display_keys]
            rows = [[str(record.get(key, '')) for key in display_keys] for record in data]
            
            # Format this table
            if rows:
                table_output = format_table(headers, rows)
                output_parts.append(table_output)
        
        return format_output('\n\n'.join(output_parts) if output_parts else "No records found", output_format)

def build_queue_vault_data(function_name, args):
    """Build vault data for queue item based on function and arguments"""
    func_def = QUEUE_FUNCTIONS.get(function_name)
    if not func_def:
        return None
    
    # Build parameters from provided arguments
    params = {}
    for param_name, param_info in func_def.get('params', {}).items():
        # Get parameter value from args
        value = getattr(args, param_name, None)
        
        # Use default if available and value not provided
        if value is None and 'default' in param_info:
            value = param_info['default']
        
        # Skip if not required and not provided
        if value is None and not param_info.get('required', False):
            continue
        
        # Add to params if we have a value
        if value is not None:
            params[param_name] = value
    
    # Create vault data structure
    vault_data = {
        'type': 'bash_function',
        'function': function_name,
        'params': params,
        'description': args.description or func_def.get('description', ''),
        'priority': args.priority
    }
    
    return json.dumps(vault_data)

class CommandHandler:
    """Unified command handler"""
    def __init__(self, config_manager, output_format='text'):
        self.config = config_manager.config
        self.config_manager = config_manager
        self.client = APIClient(self.config, config_manager)
        self.output_format = output_format
    
    def handle_response(self, response, success_message=None, format_args=None):
        """Handle API response and print appropriate message"""
        if response.get('error'):
            output = format_output(None, self.output_format, None, response['error'])
            print(output)
            return False
        
        # Extract task ID if present for queue operations
        if success_message and format_args and '{task_id}' in success_message:
            tables = response.get('tables', [])
            if len(tables) > 1 and tables[1].get('data'):
                task_id = tables[1]['data'][0].get('taskId', tables[1]['data'][0].get('TaskId'))
                if task_id:
                    setattr(format_args, 'task_id', task_id)
        
        if success_message and self.output_format != 'json':
            if format_args:
                success_message = success_message.format(**{k: getattr(format_args, k, '') 
                                                           for k in dir(format_args) 
                                                           if not k.startswith('_')})
            print(colorize(success_message, 'GREEN'))
        elif success_message and self.output_format == 'json':
            if format_args:
                success_message = success_message.format(**{k: getattr(format_args, k, '') 
                                                           for k in dir(format_args) 
                                                           if not k.startswith('_')})
            # For create queue item, include task ID in response
            data = {}
            if hasattr(format_args, 'task_id') and format_args.task_id:
                data['task_id'] = format_args.task_id
            output = format_output(data, self.output_format, success_message)
            print(output)
            
        return True
    
    def login(self, args):
        """Log in to the Rediacc API"""
        email = args.email or input("Email: ")
        password = args.password or getpass.getpass("Password: ")
        
        hash_pwd = pwd_hash(password)
        
        # Try to create authentication request
        response = self.client.auth_request(
            "CreateAuthenticationRequest", 
            email, hash_pwd, 
            {"name": args.session_name or "CLI Session"}
        )
        
        if response.get('error'):
            output = format_output(None, self.output_format, None, f"Login failed: {response['error']}")
            print(output)
            return 1
        
        # Extract token from response
        tables = response.get('tables', [])
        if not tables or not tables[0].get('data'):
            error_msg = "Login failed: Could not get authentication token"
            output = format_output(None, self.output_format, None, error_msg)
            print(output)
            return 1
        
        token = tables[0]['data'][0].get('nextRequestCredential')
        if not token:
            error_msg = "Login failed: Invalid authentication token"
            output = format_output(None, self.output_format, None, error_msg)
            print(output)
            return 1
        
        # Get company info
        company_response = self.client.request(
            "GetUserCompany", {}, 
            {"Rediacc-UserEmail": email, "Rediacc-UserHash": hash_pwd}
        )
        
        company = None
        if not company_response.get('error'):
            company_data = extract_table_data(company_response)
            if company_data:
                company = company_data[0].get('name')
        
        # Save authentication data
        self.config_manager.set_auth(email, token, company)
        
        # Generate output based on format
        if self.output_format == 'json':
            result = {
                'email': email,
                'company': company
            }
            output = format_output(result, self.output_format, f"Successfully logged in as {email}")
            print(output)
        else:
            print(colorize(f"Successfully logged in as {email}", 'GREEN'))
            if company:
                print(f"Company: {company}")
        
        return 0
    
    def logout(self, args):
        """Log out from the Rediacc API"""
        # Delete the user request if we have a token
        if self.config.get('token'):
            self.client.token_request("DeleteUserRequest")
        
        # Clear local auth data
        self.config_manager.clear_auth()
        
        output = format_output({}, self.output_format, "Successfully logged out")
        print(output)
        return 0
    
    def queue_add(self, args):
        """Add a bash function to the queue"""
        # Validate function exists
        func_def = QUEUE_FUNCTIONS.get(args.function)
        if not func_def:
            error = f"Unknown function: {args.function}"
            output = format_output(None, self.output_format, None, error)
            print(output)
            return 1
        
        # Collect parameters for the function
        for param_name, param_info in func_def.get('params', {}).items():
            if not hasattr(args, param_name):
                setattr(args, param_name, None)
            
            # Prompt for required parameters if not provided
            if param_info.get('required', False) and getattr(args, param_name) is None:
                if self.output_format == 'json':
                    error = f"Missing required parameter: {param_name}"
                    output = format_output(None, self.output_format, None, error)
                    print(output)
                    return 1
                else:
                    value = input(f"{param_info.get('help', param_name)}: ")
                    setattr(args, param_name, value)
        
        # Build vault data
        vault_data = build_queue_vault_data(args.function, args)
        if not vault_data:
            error = "Failed to build queue item data"
            output = format_output(None, self.output_format, None, error)
            print(output)
            return 1
        
        # Create the queue item
        response = self.client.token_request(
            "CreateQueueItem",
            {
                'teamName': args.team,
                'machineName': args.machine,
                'queueVault': vault_data
            }
        )
        
        if response.get('error'):
            output = format_output(None, self.output_format, None, response['error'])
            print(output)
            return 1
        
        # Extract task ID
        tables = response.get('tables', [])
        task_id = None
        if len(tables) > 1 and tables[1].get('data'):
            task_id = tables[1]['data'][0].get('taskId', tables[1]['data'][0].get('TaskId'))
        
        if self.output_format == 'json':
            result = {
                'task_id': task_id,
                'function': args.function,
                'team': args.team,
                'machine': args.machine
            }
            output = format_output(result, self.output_format, f"Successfully queued {args.function}")
            print(output)
        else:
            print(colorize(f"Successfully queued {args.function} for machine {args.machine}", 'GREEN'))
            if task_id:
                print(f"Task ID: {task_id}")
        
        return 0
    
    def queue_list_functions(self, args):
        """List available functions that can be queued"""
        if self.output_format == 'json':
            # JSON output with full function details
            result = {}
            for func_name, func_def in QUEUE_FUNCTIONS.items():
                result[func_name] = {
                    'description': func_def.get('description', ''),
                    'params': {}
                }
                for param_name, param_info in func_def.get('params', {}).items():
                    result[func_name]['params'][param_name] = {
                        'type': param_info.get('type', 'string'),
                        'required': param_info.get('required', False),
                        'default': param_info.get('default', None),
                        'help': param_info.get('help', '')
                    }
            output = format_output(result, self.output_format)
            print(output)
        else:
            # Text output with formatted table
            print(colorize("Available Queue Functions", 'HEADER'))
            print("=" * 80)
            
            for func_name, func_def in sorted(QUEUE_FUNCTIONS.items()):
                print(f"\n{colorize(func_name, 'BLUE')}")
                print(f"  {func_def.get('description', 'No description available')}")
                
                params = func_def.get('params', {})
                if params:
                    print("  Parameters:")
                    for param_name, param_info in params.items():
                        required = "[required]" if param_info.get('required', False) else "[optional]"
                        default = f" (default: {param_info.get('default')})" if 'default' in param_info else ""
                        help_text = param_info.get('help', '')
                        print(f"    - {param_name} {colorize(required, 'YELLOW')}{default}")
                        if help_text:
                            print(f"      {help_text}")
                else:
                    print("  No parameters required")
        
        return 0
    
    def generic_command(self, cmd_type, resource_type, args):
        """Handle generic commands using configuration"""
        # Special handling for queue commands
        if cmd_type == 'queue':
            if resource_type == 'add':
                return self.queue_add(args)
            elif resource_type == 'list-functions':
                return self.queue_list_functions(args)
        
        if cmd_type not in CMD_CONFIG or resource_type not in CMD_CONFIG[cmd_type]:
            error = f"Unsupported command: {cmd_type} {resource_type}"
            output = format_output(None, self.output_format, None, error)
            print(output)
            return 1
        
        cmd_config = CMD_CONFIG[cmd_type][resource_type]
        
        # Check if auth is required (default is True unless specified otherwise)
        auth_required = cmd_config.get('auth_required', True)
        
        # Handle special case for user create which needs a password prompt
        if cmd_type == 'create' and resource_type == 'user' and not hasattr(args, 'password'):
            args.password = getpass.getpass("Password for new user: ")
        
        # Handle special case for user update-password which needs a password prompt
        if cmd_type == 'user' and resource_type == 'update-password' and not args.new_password:
            args.new_password = getpass.getpass("New password: ")
        
        # For remove commands, confirm before proceeding (unless JSON output or force flag)
        confirm_msg = cmd_config.get('confirm_msg')
        if confirm_msg and not args.force and self.output_format != 'json':
            confirm_msg = confirm_msg.format(**{k: getattr(args, k, '') 
                                                             for k in dir(args) 
                                                             if not k.startswith('_')})
            confirm = input(f"{confirm_msg} [y/N] ")
            if confirm.lower() != 'y':
                print("Operation cancelled")
                return 0
        
        # Handle vault commands specially
        if cmd_type == 'vault':
            if resource_type == 'set':
                return self.vault_set(args)
            return 1
        
        # Prepare parameters
        params = cmd_config['params'](args) if callable(cmd_config.get('params')) else {}
        
        # Execute API request
        if cmd_config.get('auth_type') == 'credentials' and hasattr(args, 'email'):
            # Use credential authentication (for company creation)
            email = args.email or input("Admin Email: ")
            password = args.password
            if not password:
                password = getpass.getpass("Admin Password: ")
                confirm = getpass.getpass("Confirm Password: ")
                if password != confirm:
                    error = "Passwords do not match"
                    output = format_output(None, self.output_format, None, error)
                    print(output)
                    return 1
            
            response = self.client.auth_request(
                cmd_config['endpoint'], email, pwd_hash(password), params
            )
        elif not auth_required:
            # No authentication required
            response = self.client.request(cmd_config['endpoint'], params)
        else:
            # Use token authentication
            response = self.client.token_request(cmd_config['endpoint'], params)
        
        # For list commands or permission list commands, format the output
        if cmd_type == 'list' or (cmd_type == 'permission' and resource_type in ['list-groups', 'list-group']) or \
           (cmd_type == 'team-member' and resource_type == 'list') or \
           (cmd_type == 'queue' and resource_type == 'get-next'):
            if response.get('error'):
                output = format_output(None, self.output_format, None, response['error'])
                print(output)
                return 1
            
            result = format_dynamic_tables(response, self.output_format)
            print(result)
            return 0
        
        # For create queue-item, handle special response
        if cmd_type == 'create' and resource_type == 'queue-item':
            success_msg = cmd_config.get('success_msg')
            # Create a simple object to hold task_id for format_args
            class Args:
                pass
            format_args = Args()
            for k in dir(args):
                if not k.startswith('_'):
                    setattr(format_args, k, getattr(args, k))
            
            if self.handle_response(response, success_msg, format_args):
                # If we have a task ID, print it
                if hasattr(format_args, 'task_id') and format_args.task_id and self.output_format != 'json':
                    print(f"Task ID: {format_args.task_id}")
                return 0
            return 1
        
        # For other commands, handle the response
        success_msg = cmd_config.get('success_msg')
        if self.handle_response(response, success_msg, args):
            return 0
        return 1
    
    def inspect_resource(self, resource_type, args):
        """Handle inspect commands"""
        if resource_type == 'team':
            # Get team details and members
            response = self.client.token_request("GetTeamMembers", {"teamName": args.name})
            
            if response.get('error'):
                output = format_output(None, self.output_format, None, response['error'])
                print(output)
                return 1
            
            members = extract_table_data(response, table_index=1)
            
            # Get team machines
            machines_response = self.client.token_request("GetTeamMachines", {"teamName": args.name})
            
            machines = []
            if not machines_response.get('error'):
                machines = extract_table_data(machines_response, table_index=1)
            
            if self.output_format == 'json':
                # JSON output
                result = {
                    'team': args.name,
                    'members_count': len(members),
                    'machines_count': len(machines),
                    'members': [{'email': m.get('userEmail', 'N/A')} for m in members],
                    'machines': [{'name': m.get('machineName', 'N/A'), 'bridge': m.get('bridgeName', 'N/A')} for m in machines]
                }
                output = format_output(result, self.output_format)
                print(output)
            else:
                # Text output
                print(colorize(f"Team: {args.name}", 'HEADER'))
                print(f"Members: {len(members)}")
                print(f"Machines: {len(machines)}")
                
                # Print member and machine details
                if members:
                    print("\nMembers:")
                    for member in members:
                        print(f"  - {member.get('userEmail', 'N/A')}")
                
                if machines:
                    print("\nMachines:")
                    for machine in machines:
                        print(f"  - {machine.get('machineName', 'N/A')} ({machine.get('bridgeName', 'N/A')})")
            
            return 0
            
        elif resource_type == 'machine':
            # Get machine details
            response = self.client.token_request("GetTeamMachines", {"teamName": args.team})
            
            if response.get('error'):
                output = format_output(None, self.output_format, None, response['error'])
                print(output)
                return 1
            
            machines = extract_table_data(response, table_index=1)
            target_machine = next((m for m in machines if m.get('machineName') == args.name), None)
            
            if not target_machine:
                error = f"Machine not found: {args.name}"
                output = format_output(None, self.output_format, None, error)
                print(output)
                return 1
            
            # Get queue items
            queue_response = self.client.token_request(
                "GetQueueItemsNext", {"machineName": args.name, "itemCount": 5}
            )
            
            queue_items = []
            if not queue_response.get('error'):
                queue_items = extract_table_data(queue_response, table_index=1)
            
            if self.output_format == 'json':
                # JSON output
                result = {
                    'machine': args.name,
                    'team': args.team,
                    'bridge': target_machine.get('bridgeName', 'N/A'),
                    'region': target_machine.get('regionName', 'N/A'),
                    'queue_count': target_machine.get('queueCount', 0),
                    'vault_version': target_machine.get('vaultVersion', 0),
                    'queue_items': [{'task_id': item.get('taskId', 'N/A')} for item in queue_items]
                }
                output = format_output(result, self.output_format)
                print(output)
            else:
                # Text output
                print(colorize(f"Machine: {args.name}", 'HEADER'))
                print(f"Team: {args.team}")
                print(f"Bridge: {target_machine.get('bridgeName', 'N/A')}")
                print(f"Region: {target_machine.get('regionName', 'N/A')}")
                print(f"Queue Count: {target_machine.get('queueCount', 0)}")
                print(f"Vault Version: {target_machine.get('vaultVersion', 0)}")
                
                if queue_items:
                    print(f"\nQueue Items: {len(queue_items)}")
                    for item in queue_items:
                        print(f"  - {item.get('taskId', 'N/A')}")
            
            return 0
        
        error = f"Unsupported resource type: {resource_type}"
        output = format_output(None, self.output_format, None, error)
        print(output)
        return 1
    
    def update_resource(self, resource_type, args):
        """Handle update commands"""
        success = True
        result_data = {}
        
        if resource_type == 'team':
            if args.new_name:
                # Update team name
                response = self.client.token_request(
                    "UpdateTeamName", 
                    {"currentTeamName": args.name, "newTeamName": args.new_name}
                )
                
                success_msg = f"Successfully renamed team: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['team_name'] = args.new_name
            
            # Update vault if provided
            if (args.vault or args.vault_file) and success:
                vault_data = get_vault_data(args)
                team_name = args.new_name if args.new_name else args.name
                
                response = self.client.token_request(
                    "UpdateTeamVault", 
                    {
                        "teamName": team_name,
                        "teamVault": vault_data,
                        "vaultVersion": args.vault_version or 1
                    }
                )
                
                if not self.handle_response(response, "Successfully updated team vault"):
                    success = False
                else:
                    result_data['vault_updated'] = True
                    result_data['vault_version'] = args.vault_version or 1
        
        elif resource_type == 'region':
            if args.new_name:
                # Update region name
                response = self.client.token_request(
                    "UpdateRegionName", 
                    {"currentRegionName": args.name, "newRegionName": args.new_name}
                )
                
                success_msg = f"Successfully renamed region: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['region_name'] = args.new_name
        
        elif resource_type == 'bridge':
            if args.new_name:
                # Update bridge name
                response = self.client.token_request(
                    "UpdateBridgeName", 
                    {
                        "regionName": args.region,
                        "currentBridgeName": args.name,
                        "newBridgeName": args.new_name
                    }
                )
                
                success_msg = f"Successfully renamed bridge: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['bridge_name'] = args.new_name
        
        elif resource_type == 'machine':
            team_name = args.team
            result_data['team'] = team_name
            
            if args.new_name:
                # Update machine name
                response = self.client.token_request(
                    "UpdateMachineName", 
                    {
                        "teamName": team_name,
                        "currentMachineName": args.name,
                        "newMachineName": args.new_name
                    }
                )
                
                success_msg = f"Successfully renamed machine: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['machine_name'] = args.new_name
            
            # Update bridge if provided
            if args.new_bridge and success:
                machine_name = args.new_name if args.new_name else args.name
                
                response = self.client.token_request(
                    "UpdateMachineAssignedBridge", 
                    {
                        "teamName": team_name,
                        "machineName": machine_name,
                        "newBridgeName": args.new_bridge
                    }
                )
                
                success_msg = f"Successfully updated machine bridge: → {args.new_bridge}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['bridge'] = args.new_bridge
            
            # Update vault if provided
            if (args.vault or args.vault_file) and success:
                vault_data = get_vault_data(args)
                machine_name = args.new_name if args.new_name else args.name
                
                response = self.client.token_request(
                    "UpdateMachineVault", 
                    {
                        "teamName": team_name,
                        "machineName": machine_name,
                        "machineVault": vault_data,
                        "vaultVersion": args.vault_version or 1
                    }
                )
                
                if not self.handle_response(response, "Successfully updated machine vault"):
                    success = False
                else:
                    result_data['vault_updated'] = True
                    result_data['vault_version'] = args.vault_version or 1
        
        elif resource_type == 'repository':
            if args.new_name:
                # Update repository name
                response = self.client.token_request(
                    "UpdateRepositoryName", 
                    {
                        "teamName": args.team,
                        "currentRepoName": args.name,
                        "newRepoName": args.new_name
                    }
                )
                
                success_msg = f"Successfully renamed repository: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['repository_name'] = args.new_name
        
        elif resource_type == 'storage':
            if args.new_name:
                # Update storage name
                response = self.client.token_request(
                    "UpdateStorageName", 
                    {
                        "teamName": args.team,
                        "currentStorageName": args.name,
                        "newStorageName": args.new_name
                    }
                )
                
                success_msg = f"Successfully renamed storage: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['storage_name'] = args.new_name
        
        elif resource_type == 'schedule':
            if args.new_name:
                # Update schedule name
                response = self.client.token_request(
                    "UpdateScheduleName", 
                    {
                        "teamName": args.team,
                        "currentScheduleName": args.name,
                        "newScheduleName": args.new_name
                    }
                )
                
                success_msg = f"Successfully renamed schedule: {args.name} → {args.new_name}"
                if not self.handle_response(response, success_msg):
                    success = False
                else:
                    result_data['schedule_name'] = args.new_name
        
        else:
            error = f"Unsupported resource type: {resource_type}"
            output = format_output(None, self.output_format, None, error)
            print(output)
            return 1
        
        # If JSON output and operations were successful, show summary
        if self.output_format == 'json' and success and result_data:
            output = format_output(result_data, self.output_format, "Update completed successfully")
            print(output)
        
        return 0 if success else 1
    
    def vault_set(self, args):
        """Set vault data for a resource"""
        resource_type = args.resource_type
        endpoints = CMD_CONFIG['vault']['set']['endpoints']
        
        if resource_type not in endpoints:
            error = f"Unsupported resource type: {resource_type}"
            output = format_output(None, self.output_format, None, error)
            print(output)
            return 1
        
        params = get_vault_set_params(args)
        if not params:
            return 1
        
        response = self.client.token_request(endpoints[resource_type], params)
        
        success_msg = f"Successfully updated {resource_type} vault"
        if self.handle_response(response, success_msg):
            if self.output_format == 'json':
                result = {
                    'resource_type': resource_type,
                    'vault_version': params.get('vaultVersion', 1)
                }
                if resource_type != 'company':
                    result['name'] = args.name
                if resource_type in ['machine', 'repository', 'storage', 'schedule']:
                    result['team'] = args.team
                if resource_type == 'bridge':
                    result['region'] = args.region
                
                output = format_output(result, self.output_format, success_msg)
                print(output)
            return 0
        return 1

def setup_parser():
    """Create and configure the argument parser from definitions"""
    parser = argparse.ArgumentParser(
        description='Rediacc CLI - Complete interface for Rediacc Middleware API with enhanced queue support'
    )
    # Add global output format option
    parser.add_argument('--output', '-o', choices=['text', 'json'], default='text',
                       help='Output format (text or json)')
    
    subparsers = parser.add_subparsers(dest='command', help='Command')
    
    # Add command parsers
    for cmd_name, cmd_def in ARG_DEFS.items():
        if isinstance(cmd_def, list):  # Simple command without subcommands
            cmd_parser = subparsers.add_parser(cmd_name, help=f"{cmd_name} command")
            for arg in cmd_def:
                kwargs = {k: v for k, v in arg.items() if k != 'name'}
                cmd_parser.add_argument(arg['name'], **kwargs)
        else:  # Command with subcommands
            cmd_parser = subparsers.add_parser(cmd_name, help=f"{cmd_name} command")
            subcmd_parsers = cmd_parser.add_subparsers(dest='resource', help='Resource')
            
            for subcmd_name, subcmd_def in cmd_def.items():
                subcmd_parser = subcmd_parsers.add_parser(subcmd_name, help=f"{subcmd_name} resource")
                
                # Special handling for queue add command - add function-specific arguments
                if cmd_name == 'queue' and subcmd_name == 'add':
                    # Add the basic arguments
                    for arg in subcmd_def:
                        kwargs = {k: v for k, v in arg.items() if k != 'name'}
                        subcmd_parser.add_argument(arg['name'], **kwargs)
                    
                    # Add all possible function parameters as optional arguments
                    # Use a dict to ensure unique parameter names
                    all_params = {}
                    for func_def in QUEUE_FUNCTIONS.values():
                        for param_name, param_info in func_def.get('params', {}).items():
                            # Only add if not already present or update with more descriptive help
                            if param_name not in all_params or len(param_info.get('help', '')) > len(all_params[param_name]):
                                all_params[param_name] = param_info.get('help', f'Parameter for function')
                    
                    # Add each unique parameter
                    for param_name, help_text in sorted(all_params.items()):
                        # Skip parameters that might conflict with Python keywords or argparse
                        if param_name.replace('-', '_').replace('_', '').isidentifier():
                            subcmd_parser.add_argument(f'--{param_name.replace("_", "-")}', 
                                                     dest=param_name,
                                                     help=help_text)
                else:
                    # Normal argument handling
                    for arg in subcmd_def:
                        kwargs = {k: v for k, v in arg.items() if k != 'name'}
                        subcmd_parser.add_argument(arg['name'], **kwargs)
    
    return parser

def main():
    """Main CLI entry point"""
    parser = setup_parser()
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Get output format
    output_format = args.output
    
    # Load configuration
    config_manager = ConfigManager()
    handler = CommandHandler(config_manager, output_format)
    
    # Handle authentication commands directly
    if args.command == 'login':
        return handler.login(args)
    elif args.command == 'logout':
        return handler.logout(args)
    
    # Check if command requires authentication
    auth_not_required_commands = {
        ('user', 'activate'),
        ('create', 'company')
    }
    
    # Check if authenticated for commands that require it
    if (args.command, getattr(args, 'resource', None)) not in auth_not_required_commands:
        if not config_manager.is_authenticated():
            error = "Not authenticated. Please login first."
            output = format_output(None, output_format, None, error)
            print(output)
            return 1
    
    # Handle other commands with resource types
    if not hasattr(args, 'resource') or not args.resource:
        error = f"No resource specified for command: {args.command}"
        output = format_output(None, output_format, None, error)
        print(output)
        return 1
    
    # Special handling for certain commands
    if args.command == 'inspect':
        return handler.inspect_resource(args.resource, args)
    elif args.command == 'update':
        return handler.update_resource(args.resource, args)
    else:
        # Generic command handling for create, list, rm, vault, permission, user, team-member, queue
        return handler.generic_command(args.command, args.resource, args)

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(130)