{
  "API_ENDPOINTS": {
    "create": {
      "company": {
        "endpoint": "CreateNewCompany",
        "auth_required": false,
        "auth_type": "credentials",
        "params": "lambda args: {'companyName': args.company_name, 'activationCode': args.activation_code, 'subscriptionPlan': args.subscription_plan, 'companyVaultDefaults': args.vault_defaults}",
        "success_msg": "Successfully created company: {name}",
        "help": {
          "description": "Create a new company account with admin user",
          "details": "Creates a new Rediacc company along with its admin user account. The email and password parameters are used to create the admin user who will own the company. This is typically the first step in setting up a new Rediacc deployment.",
          "parameters": {
            "activation_code": {
              "description": "",
              "required": false,
              "example": ""
            },
            "vault_defaults": {
              "description": "",
              "required": false,
              "example": ""
            },
            "company_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "subscription_plan": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "Password hash must be exactly 32 bytes when hashed",
            "Activation code must be exactly 6 characters",
            "User email must not already exist in the system",
            "Email format must be valid (contains @ and .)",
            "Subscription plan must exist and be active (COMMUNITY, ADVANCED, PREMIUM, or ELITE)",
            "Company name is required and cannot be empty",
            "Default company vault configuration will be applied automatically",
            "COMMUNITY plan gets 10 years subscription, other plans get 30-day trial",
            "Company creation is atomic - all or nothing operation",
            "Email validation checks for proper format with @ symbol and domain"
          ]
        }
      },
      "user": {
        "endpoint": "CreateNewUser",
        "params": "lambda args: {'newUserEmail': args.new_user_email, 'newUserHash': args.new_user_hash, 'activationCode': args.activation_code}",
        "success_msg": "Successfully created user: {email}",
        "help": {
          "description": "Create a new user in your company",
          "details": "Creates a new user account that can access the company resources. Users must be activated before they can log in.",
          "parameters": {
            "activation_code": {
              "description": "",
              "required": false,
              "example": ""
            },
            "new_user_email": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "new_user_hash": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User email must not already exist in the system",
            "Password hash must be exactly 32 bytes",
            "Activation code must be exactly 6 characters",
            "Email format validation is performed",
            "Company must not have exceeded user resource limits",
            "User creation is atomic with transactional safety",
            "New users are created in inactive state and must be activated",
            "Empty user vault is created automatically",
            "Resource limits depend on subscription plan",
            "User email must be unique across the entire system"
          ]
        }
      },
      "team": {
        "endpoint": "CreateTeam",
        "params": "lambda args: {'teamName': args.name, 'teamVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created team: {name}",
        "help": {
          "description": "Create a new team in your company",
          "details": "Teams are organizational units that own machines, repositories, and other resources. Team members can manage all resources within the team.",
          "parameters": {
            "name": {
              "description": "Unique name for the team",
              "required": true,
              "example": "production-team"
            },
            "vault": {
              "description": "JSON object with team configuration (SSH keys, settings)",
              "required": false,
              "example": "{\"SSH_PRIVATE_KEY\": \"-----BEGIN RSA...\"}"
            },
            "vault-file": {
              "description": "File containing JSON vault data",
              "required": false,
              "example": "team-config.json"
            }
          },
          "examples": [
            {
              "command": "rediacc create team production-team",
              "description": "Create a basic team"
            },
            {
              "command": "rediacc create team dev-team --vault-file team-config.json",
              "description": "Create team with vault configuration from file"
            }
          ],
          "notes": "Team creation counts against your subscription limits. The creator automatically becomes a team member.",
          "rules": [
            "Team name must be unique within the company",
            "Team vault data cannot be null or empty",
            "User must pass authentication and authorization checks",
            "Company must not have exceeded team resource limits",
            "Creator is automatically added as a team member",
            "Team names are case-sensitive",
            "Vault data must be valid JSON format",
            "Resource limits depend on subscription plan",
            "Team creation is tracked in audit log",
            "Bridge users cannot be added to teams"
          ]
        }
      },
      "region": {
        "endpoint": "CreateRegion",
        "params": "lambda args: {'regionName': args.name, 'regionVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created region: {name}",
        "help": {
          "description": "Create a new region for organizing bridges",
          "details": "Regions are logical or geographic groupings for bridges. They help organize infrastructure deployment across different locations or environments. Bridges must be associated with a region.",
          "parameters": {
            "name": {
              "description": "Unique name for the region (e.g., us-east, europe-west)",
              "required": true,
              "example": "us-east"
            },
            "vault": {
              "description": "JSON configuration for the region (provider settings, metadata)",
              "required": false,
              "example": "{\"provider\": \"aws\", \"zone\": \"us-east-1\"}"
            },
            "vault-file": {
              "description": "File containing JSON vault configuration",
              "required": false,
              "example": "region-config.json"
            }
          },
          "examples": [
            {
              "command": "rediacc create region us-east",
              "description": "Create a basic region"
            },
            {
              "command": "rediacc create region europe-west --vault '{\"provider\":\"azure\",\"location\":\"westeurope\"}'",
              "description": "Create region with provider configuration"
            }
          ],
          "notes": "Regions cannot be deleted if they contain bridges. Region names must be unique across the company.",
          "rules": [
            "Region name must be unique within the company",
            "Region vault data cannot be null or empty",
            "Company must not have exceeded region resource limits",
            "User must pass authentication and authorization checks",
            "Vault data must be valid JSON format",
            "Resource limits depend on subscription plan",
            "Region names are case-sensitive",
            "Regions with bridges cannot be deleted",
            "Region creation is tracked in audit log",
            "Admin permissions may be required depending on company settings"
          ]
        }
      },
      "bridge": {
        "endpoint": "CreateBridge",
        "params": "lambda args: {'regionName': args.region, 'bridgeName': args.name, 'bridgeVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created bridge: {name} in region {region}",
        "help": {
          "description": "Create a new bridge for task processing",
          "details": "Bridges are autonomous queue processors that poll for tasks and execute them on machines via SSH. They run in bridge mode and can process multiple queue items in parallel. Each bridge must belong to a region.",
          "parameters": {
            "region": {
              "description": "Region where the bridge will be created",
              "required": true,
              "example": "us-east"
            },
            "vault": {
              "description": "JSON configuration for the bridge (batch size, timeout settings)",
              "required": false,
              "example": "{\"batch_size\": 5, \"poll_interval\": 30}"
            },
            "bridge": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc create bridge us-east bridge-01",
              "description": "Create a basic bridge"
            },
            {
              "command": "rediacc create bridge us-east high-priority-bridge --vault '{\"batch_size\":10}'",
              "description": "Create bridge with custom batch size"
            }
          ],
          "notes": "After creation, start the bridge with './bridge --bridge-mode token=<token> api_url=<url> master_password=<pwd>'. Use 'rediacc login --target bridge-name' to get a bridge-specific token.",
          "rules": [
            "Bridge name must be unique within the region",
            "Region must exist and belong to the user's company",
            "Bridge vault data cannot be null or empty",
            "Company must not have exceeded bridge resource limits",
            "User must have appropriate permissions",
            "Vault data must be valid JSON format",
            "Resource limits depend on subscription plan",
            "Bridge names are case-sensitive",
            "A bridge user account is automatically created for authentication",
            "Bridge credentials are stored securely in the vault"
          ]
        }
      },
      "machine": {
        "endpoint": "CreateMachine",
        "params": "lambda args: {'teamName': args.team, 'bridgeName': args.bridge, 'machineName': args.name, 'machineVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created machine: {name} for team {team}",
        "help": {
          "description": "Create a new machine in a team",
          "details": "Machines are remote servers that execute tasks via SSH. They must be associated with a team and connected through a bridge. Machine names must be unique across the entire company.",
          "parameters": {
            "team": {
              "description": "Team that will own this machine",
              "required": true,
              "example": "production-team"
            },
            "bridge": {
              "description": "Bridge to connect through (must exist in a region)",
              "required": true,
              "example": "us-east-bridge-01"
            },
            "vault": {
              "description": "JSON with machine config (ip, user, ssh_port, datastore)",
              "required": false,
              "example": "{\"ip\": \"10.0.0.5\", \"user\": \"rediacc\", \"datastore\": \"/mnt/datastore\"}"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc create machine production-team us-east-bridge web-01",
              "description": "Create a basic machine"
            },
            {
              "command": "rediacc create machine prod us-bridge db-01 --vault '{\"ip\":\"10.0.0.10\"}'",
              "description": "Create machine with IP configuration"
            }
          ],
          "notes": "You must be a member of the team. The bridge must exist and be accessible. Machine creation counts against subscription limits.",
          "rules": [
            "Machine name must be unique across the entire company (not just within team)",
            "User must be a member of the specified team",
            "Bridge must exist in a region within the company",
            "Company must not have exceeded machine resource limits",
            "Machine vault data cannot be null or empty",
            "Vault data must be valid JSON format",
            "Team must exist within the user's company",
            "Resource limits depend on subscription plan",
            "Machine names are case-sensitive",
            "Bridge must be accessible and properly configured"
          ]
        }
      },
      "repository": {
        "endpoint": "CreateRepository",
        "params": "lambda args: {'teamName': args.team, 'repoName': args.repository, 'repoVault': get_vault_data(args) or '{}', 'parentRepoName': args.parent_repo, 'repoGuid': args.repo_guid}",
        "success_msg": "Successfully created repository: {name} for team {team}",
        "help": {
          "description": "Create a new repository for code and data storage",
          "details": "Repositories are isolated environments for storing code, data, or applications. They support Docker-based deployments via Rediaccfile, have dedicated storage volumes, and can be synchronized across machines.",
          "parameters": {
            "team": {
              "description": "Team that will own this repository",
              "required": true,
              "example": "dev-team"
            },
            "vault": {
              "description": "JSON configuration (size, type, settings)",
              "required": false,
              "example": "{\"size\": \"10G\", \"type\": \"docker\"}"
            },
            "parent_repo": {
              "description": "",
              "required": false,
              "example": ""
            },
            "repository": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "repo_guid": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "Repository name must be unique within the team",
            "User must be a member of the specified team",
            "Repository vault data cannot be null or empty",
            "Company must not have exceeded repository resource limits",
            "Team must exist within the user's company",
            "Vault data must be valid JSON format",
            "Parent repository must exist if specified",
            "Resource limits depend on subscription plan",
            "Repository names are case-sensitive",
            "Parent repository must be in the same team",
            "GUID must be a valid UUID format if specified",
            "GUID must be unique across all repositories if specified",
            "GUID is auto-generated if not provided"
          ]
        }
      },
      "storage": {
        "endpoint": "CreateStorage",
        "params": "lambda args: {'teamName': args.team, 'storageName': args.storage, 'storageVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created storage: {name} for team {team}",
        "help": {
          "description": "Create a new storage resource",
          "details": "Storage resources represent external storage systems like S3 buckets, Azure Blob Storage, or network shares. They're used for backups, archives, and data exchange between systems.",
          "parameters": {
            "team": {
              "description": "Team that will own this storage",
              "required": true,
              "example": "data-team"
            },
            "vault": {
              "description": "JSON with storage credentials and configuration",
              "required": false,
              "example": "{\"type\": \"s3\", \"bucket\": \"my-backups\", \"region\": \"us-east-1\", \"access_key\": \"...\", \"secret_key\": \"...\"}"
            },
            "storage": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc create storage backup-team s3-archive",
              "description": "Create a basic storage resource"
            },
            {
              "command": "rediacc create storage prod azure-backup --vault-file azure-config.json",
              "description": "Create Azure storage with credentials from file"
            }
          ],
          "notes": "Storage credentials are encrypted in the vault. Supported types include S3, Azure Blob, GCS, SFTP, and SMB. Used with 'repo_push' and 'repo_pull' queue functions.",
          "rules": [
            "Storage name must be unique within the team",
            "User must be a member of the specified team",
            "Storage vault data cannot be null or empty",
            "Company must not have exceeded storage resource limits",
            "Team must exist within the user's company",
            "Vault data must be valid JSON format",
            "Resource limits depend on subscription plan",
            "Storage names are case-sensitive",
            "Credentials in vault are automatically encrypted",
            "Storage types must be supported (S3, Azure, GCS, SFTP, SMB)"
          ]
        }
      },
      "queue-item": {
        "endpoint": "CreateQueueItem",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.machine, 'bridgeName': args.bridge, 'queueVault': get_vault_data(args) or '{}', 'priority': args.priority}",
        "success_msg": "Successfully created queue item for machine {machine} with priority {priority}",
        "help": {
          "description": "Create a queue item for task execution",
          "details": "Queue items represent tasks to be executed on machines by bridges. The bridge polls for items, executes them on the target machine via SSH, and reports results back.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "production-team"
            },
            "machine": {
              "description": "Target machine for execution",
              "required": true,
              "example": "web-server-01"
            },
            "bridge": {
              "description": "Bridge to process this queue item",
              "required": true,
              "example": "us-east-bridge-01"
            },
            "vault": {
              "description": "JSON with task configuration and parameters",
              "required": false,
              "example": "{\"function\": \"deploy\", \"version\": \"1.2.3\"}"
            },
            "priority": {
              "description": "Priority level (1=highest, 5=lowest)",
              "required": false,
              "default": "3",
              "example": "1"
            }
          },
          "examples": [
            {
              "command": "rediacc create queue-item prod web-01 us-bridge --priority 3",
              "description": "Create standard priority queue item"
            },
            {
              "command": "rediacc create queue-item prod db-01 bridge-01 --priority 1 --vault-file task.json",
              "description": "Create high priority item with task config"
            }
          ],
          "notes": "Priority 1-2 requires Premium/Elite subscription. Community/Advanced limited to priority 3-5. You must be a team member.",
          "rules": [
            "Priority must be between 1 and 5 (1=highest, 5=lowest)",
            "Priority levels 1-2 require Premium or Elite subscription",
            "Community/Advanced plans automatically reset priority to 4 (default)",
            "User must be a member of the team that owns the machine",
            "Machine must exist and belong to the specified team",
            "Bridge must exist and be accessible",
            "Machine can be optional for bridge-only queue items",
            "Queue vault data must be valid JSON format",
            "Task execution is subject to subscription concurrency limits",
            "Bridge must be in the same company as the machine"
          ]
        }
      }
    },
    "list": {
      "teams": {
        "endpoint": "GetCompanyTeams",
        "params": "lambda args: {}",
        "help": {
          "description": "List all teams in your company",
          "details": "Displays teams with membership information, resource counts, and vault access. Only shows vault data for teams where you are a member.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list teams",
              "description": "List all teams in table format"
            },
            {
              "command": "rediacc list teams --output json",
              "description": "List all teams in JSON format for scripting"
            }
          ],
          "notes": "Requires authentication. Vault content is only visible for teams you belong to.",
          "rules": [
            "User must be authenticated with valid credentials",
            "User must belong to a company to retrieve team information",
            "All teams in the company are visible to all users",
            "Vault data (sensitive information) is only visible for teams where you are a member",
            "Teams are sorted alphabetically by name",
            "Statistics show member count, machine count, repository count, schedule count, and storage count",
            "Encrypted vault data requires company passphrase for decryption",
            "No cross-company access is allowed",
            "Membership status indicator shows 1 for member, 0 for non-member",
            "Company name is included for context"
          ]
        }
      },
      "regions": {
        "endpoint": "GetCompanyRegions",
        "params": "lambda args: {}",
        "help": {
          "description": "List all regions in your company",
          "details": "Shows geographic regions where you can deploy bridges and infrastructure. Each region can contain multiple bridges for distributed task processing.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list regions",
              "description": "Display all regions with their vault configurations"
            }
          ],
          "notes": "Regions define geographic or logical boundaries for infrastructure deployment.",
          "rules": [
            "User must be authenticated with a valid token",
            "Token must be active and not expired",
            "User must belong to a company",
            "Only regions within your company are visible",
            "Administrators can see full vault data for all regions",
            "Non-administrators cannot see sensitive vault data",
            "Bridge count is shown for each region",
            "Regions are sorted alphabetically by name",
            "No team membership required to view regions",
            "Empty result set is returned if no regions exist"
          ]
        }
      },
      "bridges": {
        "endpoint": "GetRegionBridges",
        "params": "lambda args: {'regionName': args.region}",
        "help": {
          "description": "List bridges in a specific region",
          "details": "Bridges are autonomous queue processors that execute tasks on machines. They poll for queue items and manage SSH connections to target machines.",
          "parameters": {
            "region": {
              "description": "Name of the region to list bridges from",
              "required": true,
              "example": "us-east"
            }
          },
          "examples": [
            {
              "command": "rediacc list bridges us-east",
              "description": "List all bridges in the us-east region"
            }
          ],
          "notes": "Bridges must be running in bridge mode to process queue items.",
          "rules": [
            "User must be authenticated with a valid token",
            "Region must exist within your company",
            "Region names are case-sensitive",
            "Regular users can only see vault data for bridges they have access to through team machines",
            "Access determined by: user is member of team that has machines using the bridge",
            "Administrators can see all bridge information including sensitive vault data",
            "Bridge credentials and user emails only visible to administrators",
            "Machine count shown for each bridge",
            "HasAccess indicator shows if user can use the bridge",
            "Special 'Global Bridges' entry may be shown for cloud-managed bridges"
          ]
        }
      },
      "users": {
        "endpoint": "GetCompanyUsers",
        "params": "lambda args: {}",
        "help": {
          "description": "List all users in your company",
          "details": "Shows all user accounts including their email, status (active/inactive), permission groups, TFA status, and last login information. Useful for user management and audit purposes.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list users",
              "description": "Display all company users in table format"
            },
            {
              "command": "rediacc list users --output json | jq '.[] | select(.isActive == false)'",
              "description": "Find all inactive users"
            }
          ],
          "notes": "Requires authentication. Shows user status, permissions, and security settings. Personal information like passwords is never exposed.",
          "rules": [
            "User must be logged in with valid authentication token",
            "Token must be active and not expired",
            "User account must be activated",
            "Token rotation required for security",
            "Users can only view users from their own company",
            "Administrators can see all users and their vault data",
            "Non-administrators can only see users who share at least one team with them",
            "Vault data (sensitive information) only visible to administrators",
            "Shows permission groups (Administrators, Users, or Bridges)",
            "Company boundary enforcement prevents cross-company visibility"
          ]
        }
      },
      "sessions": {
        "endpoint": "GetUserRequests",
        "params": "lambda args: {}",
        "help": {
          "description": "List active sessions and authentication requests",
          "details": "Shows all active authentication sessions including session names, creation time, expiration, permissions, and originating IP addresses. Helps monitor access and detect unauthorized sessions.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list sessions",
              "description": "View all active sessions"
            },
            {
              "command": "rediacc list sessions --output json | jq '.[] | select(.sessionName | contains(\"CLI\"))'",
              "description": "Filter CLI sessions"
            }
          ],
          "notes": "Sessions expire based on tokenExpirationHours setting. Bridge tokens may have extended expiration. Use 'logout' to terminate current session.",
          "rules": [
            "Valid session token required with matching verification code",
            "Only active sessions are accepted (not expired or logged out)",
            "Token rotation up to 3 times before requiring latest token",
            "Users can only see their own sessions",
            "Company maintenance mode blocks non-administrator access",
            "Two-factor authentication must be completed if enabled",
            "Sessions sorted by creation time (newest first)",
            "Shows session name, creation time, permissions, and expiration",
            "No administrative override - admins also see only their own sessions",
            "Zero trust security model with full authentication on every request"
          ]
        }
      },
      "resource-limits": {
        "endpoint": "GetCompanyDashboardJson",
        "params": "lambda args: {}",
        "help": {
          "description": "Display company resource limits and current usage",
          "details": "Shows your subscription limits and current usage for all resource types including teams, machines, bridges, repositories, and more. Multiple subscriptions stack their limits.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list resource-limits",
              "description": "View resource usage vs limits in table format"
            },
            {
              "command": "rediacc list resource-limits --output json | jq '.resourceLimits'",
              "description": "Extract resource limits data for monitoring"
            }
          ],
          "notes": "Useful for capacity planning and monitoring when approaching subscription limits. Returns 402 Payment Required when limits are exceeded.",
          "rules": [
            "User must be authenticated and belong to a company",
            "Resource limits are additive across multiple active subscriptions",
            "Tracks 8 resource types: regions, teams, bridges, machines, repositories, schedules, storage, users",
            "Shows current usage count vs total allowed limit",
            "Usage percentage calculated for each resource type",
            "Default to Community tier if no active subscription",
            "Queue priority feature only for Premium/Elite tiers",
            "Resource limits by tier: Community (2), Advanced (3-10), Premium (5-50), Elite (10-200)",
            "Resources at 80% or more flagged as near limit",
            "Upgrade recommended if 3+ resources at 80% capacity"
          ]
        }
      },
      "subscription": {
        "endpoint": "GetCompanyDashboardJson",
        "params": "lambda args: {}",
        "help": {
          "description": "Show subscription details and billing information",
          "details": "Displays active subscriptions, plan details, expiration dates, and feature limits. Multiple subscriptions stack their resource limits. Shows both current usage and available capacity.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list subscription",
              "description": "View subscription status and limits"
            },
            {
              "command": "rediacc list subscription --output json | jq '.subscriptions'",
              "description": "Extract subscription data for monitoring"
            }
          ],
          "notes": "Plans: COMMUNITY (free), ADVANCED, PREMIUM, ELITE. Higher tiers offer more resources, priority levels, and features like schedules and distributed storage.",
          "rules": [
            "User must be authenticated with valid session",
            "Can only view subscription information for your own company",
            "Shows highest tier subscription when multiple are active",
            "Subscription priority: Elite > Premium > Advanced > Community",
            "Active subscriptions must have ACTIVE status and future end date",
            "Resource limits are cumulative across all active subscriptions",
            "Trial subscriptions identified if 45 days or less (non-Community)",
            "Expiration warnings shown for subscriptions ending within 30 days",
            "Feature access varies by tier (Analytics for Premium/Elite, etc.)",
            "Queue priority features only visible to Premium/Elite subscribers"
          ]
        }
      },
      "data-graph": {
        "endpoint": "GetCompanyDataGraphJson",
        "params": "lambda args: {}",
        "help": {
          "description": "Display company infrastructure as a hierarchical graph",
          "details": "Shows the complete infrastructure topology including regions, bridges, teams, machines, and their relationships in a graph format.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list data-graph",
              "description": "Display infrastructure graph"
            },
            {
              "command": "rediacc list data-graph --output json | jq '.graph'",
              "description": "Extract graph data for visualization"
            }
          ],
          "notes": "Useful for understanding infrastructure topology and dependencies. JSON output can be used with graph visualization tools.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Can only view data for your own company",
            "Administrators see all infrastructure across the company",
            "Regular users only see infrastructure they have access to",
            "Access determined through team membership chain",
            "Users see teams they belong to and resources owned by those teams",
            "Machines only visible if user is member of owning team",
            "Bridges/regions visible if user has access to machines within them",
            "Data organized in hierarchical levels for visualization",
            "Both nodes and relationships filtered based on access rights"
          ]
        }
      },
      "company-vault": {
        "endpoint": "GetCompanyVault",
        "params": "lambda args: {}",
        "help": {
          "description": "View company-wide vault configuration",
          "details": "Displays the encrypted vault data stored at the company level. This typically contains global settings and shared credentials.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list company-vault",
              "description": "View company vault contents"
            }
          ],
          "notes": "Requires company admin permissions. Vault data is automatically decrypted if you have the master password configured.",
          "rules": [
            "User must be logged in with valid credentials",
            "Can only access vault data for your own company",
            "Returns company's main vault content and version",
            "Includes company name for identification",
            "Request must pass security validation",
            "Cross-company access not permitted",
            "GetCompanyVaults (admin-only) shows ALL vaults across organization",
            "Administrators can view decrypted credentials and sensitive data",
            "Two-factor authentication vaults excluded for security",
            "Bridge users allowed access for automated operations"
          ]
        }
      },
      "lookup-data": {
        "endpoint": "GetLookupData",
        "params": "lambda args: {'context': getattr(args, 'context', None)}",
        "help": {
          "description": "Get dropdown/selection data for UI components",
          "details": "Provides lookup data used for dropdowns and selection lists in UI components. Returns teams, regions, bridges, machines, users, and other selectable resources based on your permissions.",
          "parameters": {
            "context": {
              "description": "Optional context filter (e.g., 'machine_create', 'queue_create')",
              "required": false,
              "example": "machine_create"
            }
          },
          "examples": [
            {
              "command": "rediacc list lookup-data",
              "description": "Get all available lookup data"
            },
            {
              "command": "rediacc list lookup-data --context queue_create",
              "description": "Get lookup data specific to queue creation"
            }
          ],
          "notes": "Returns different data based on user permissions. Admins see all resources, regular users see only accessible resources.",
          "rules": [
            "User must be authenticated with valid token",
            "User must belong to a company",
            "Regular users only see teams they are members of",
            "Regular users only see machines belonging to their teams",
            "Regular users only see bridges/regions with accessible machines",
            "Regular users only see users in shared teams",
            "Administrators see all company resources",
            "Optional context parameter filters data for specific use cases",
            "Company isolation enforced - no cross-company visibility",
            "All data returned as JSON with value/label pairs"
          ]
        }
      },
      "user-company": {
        "endpoint": "GetUserCompany",
        "params": "lambda args: {}",
        "help": {
          "description": "Display which company the current user belongs to",
          "details": "Shows the company information for the currently authenticated user. Useful for verifying you're logged into the correct company account.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc list user-company",
              "description": "Display current user's company"
            }
          ],
          "notes": "Requires authentication. Shows company name and ID.",
          "rules": [
            "Valid authentication token required",
            "Token rotation required for security",
            "Active session must not be expired",
            "Users can only view their own company information",
            "No cross-company access allowed",
            "Company name and vault data returned",
            "Shows team count, region count, and user count statistics",
            "Each user associated with exactly one company",
            "Company passphrase used to decrypt vault data",
            "Failed validation returns no company information"
          ]
        }
      },
      "audit-logs": {
        "endpoint": "GetAuditLogs",
        "params": "lambda args: {'startDate': args.start_date, 'endDate': args.end_date, 'entityFilter': args.entity_filter, 'maxRecords': args.max_records}",
        "help": {
          "description": "View audit trail of system changes",
          "details": "Shows detailed audit logs of all system modifications including who made changes, when, and what was changed. Essential for compliance, security monitoring, and troubleshooting.",
          "parameters": {
            "start_date": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "end_date": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "entity_filter": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "max_records": {
              "description": "",
              "required": true,
              "example": "",
              "type": "integer"
            }
          },
          "examples": [
            {
              "command": "rediacc list audit-logs --start-date 2024-01-01T00:00:00Z",
              "description": "Get audit logs from specific date"
            },
            {
              "command": "rediacc list audit-logs --entity-filter Team --max-records 100",
              "description": "Get last 100 team-related changes"
            }
          ],
          "notes": "Audit logs are retained based on subscription tier. Includes create, update, delete operations and authentication events.",
          "rules": [
            "User must be authenticated",
            "Can only see audit logs for your own company",
            "Default time period is 30 days if no start date provided",
            "Start date must come before end date",
            "Default limit is 1,000 records, maximum is 10,000",
            "Administrators see all company audit logs",
            "Regular users only see logs for resources they have access to",
            "Entity type filtering is optional",
            "Sensitive operations masked for non-administrators",
            "Users can always view their own user account logs"
          ]
        }
      },
      "entity-history": {
        "endpoint": "GetEntityHistory",
        "params": "lambda args: {'entity': args.entity, 'credential': args.credential, 'maxRecords': args.max_records}",
        "help": {
          "description": "View change history for a specific entity",
          "details": "Shows the modification history for a specific entity (team, machine, user, etc.) identified by its credential GUID. Includes who made changes, when, and what was changed.",
          "parameters": {
            "credential": {
              "description": "Entity's unique credential (GUID)",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            },
            "entity": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "max_records": {
              "description": "",
              "required": true,
              "example": "",
              "type": "integer"
            }
          },
          "examples": [
            {
              "command": "rediacc list entity-history Machine 550e8400-e29b-41d4-a716-446655440000",
              "description": "View history for a specific machine"
            },
            {
              "command": "rediacc list entity-history Team 123e4567-e89b-12d3-a456-426614174000 --max-records 50",
              "description": "View last 50 changes to a team"
            }
          ],
          "notes": "Get the credential from 'inspect' commands. History includes creates, updates, deletes, and vault changes.",
          "rules": [
            "User must be authenticated",
            "Entity type is required and must be valid",
            "Entity credential (GUID) is mandatory",
            "Entity must exist in your company",
            "Access rules vary by entity type and user role",
            "Maximum 5,000 records, default 500",
            "Users can view their own history, admins see all",
            "Team/machine/repo access requires membership",
            "Sensitive operations filtered for non-administrators",
            "Access denial protects entity existence information"
          ]
        }
      },
      "team-machines": {
        "endpoint": "GetTeamMachines",
        "params": "lambda args: {'teamName': args.team}",
        "help": {
          "description": "List machines in a specific team",
          "details": "Shows all machines assigned to a team including their status, assigned bridge, vault configuration, and queue statistics. Machine names are unique across the company.",
          "parameters": {
            "team": {
              "description": "Team name to list machines from (comma-separated for multiple teams)",
              "required": true,
              "example": "production-team"
            }
          },
          "examples": [
            {
              "command": "rediacc list team-machines production-team",
              "description": "List all machines in production team"
            },
            {
              "command": "rediacc list team-machines team1,team2",
              "description": "List machines from multiple teams"
            }
          ],
          "notes": "You must be a member of the team to see its machines. Shows queue count for each machine.",
          "rules": [
            "Valid user authentication required with active session",
            "User must be a member of the team to see machines",
            "Company boundary enforced - only see machines in your company",
            "Multiple teams supported with comma-separated names",
            "No team filter returns machines from all your teams",
            "Shows machine details including bridge, region, queue count",
            "Vault information includes encrypted credentials and settings",
            "Results sorted by team name then machine name",
            "Invalid team names silently filtered out",
            "Real-time queue count helps understand workload"
          ]
        }
      },
      "team-members": {
        "endpoint": "GetTeamMembers",
        "params": "lambda args: {'teamName': args.team}",
        "help": {
          "description": "List members of a specific team",
          "details": "Shows all users who have access to a team's resources. Team members can manage all resources within the team.",
          "parameters": {
            "team": {
              "description": "Team name to list members from",
              "required": true,
              "example": "production-team"
            }
          },
          "examples": [
            {
              "command": "rediacc list team-members production-team",
              "description": "List all members of production team"
            }
          ],
          "notes": "You must be a member of the team to view its membership. Shows email addresses and join dates.",
          "rules": [
            "User must be authenticated with valid token",
            "Can only view members of teams you belong to",
            "Company boundary restriction applies",
            "Team filtering with comma-separated names supported",
            "No team specified returns members from all your teams",
            "Shows user email and activation status",
            "Results are deduplicated - each user appears once",
            "No special permissions required beyond team membership",
            "Team names are case-sensitive",
            "No administrative override for non-member access"
          ]
        }
      },
      "team-repositories": {
        "endpoint": "GetTeamRepositories",
        "params": "lambda args: {'teamName': args.team}",
        "help": {
          "description": "List all repositories owned by a team",
          "details": "Shows all code repositories associated with a team. Repositories are isolated environments for storing code, data, or applications with Docker support.",
          "parameters": {
            "team": {
              "description": "Team name to list repositories from",
              "required": true,
              "example": "dev-team"
            }
          },
          "examples": [
            {
              "command": "rediacc list team-repositories dev-team",
              "description": "List all repositories in dev-team"
            },
            {
              "command": "rediacc list team-repositories prod --output json | jq '.[].repoName'",
              "description": "Extract repository names from production team"
            }
          ],
          "notes": "You must be a member of the team. Shows repository names, credentials, and vault status.",
          "rules": [
            "User must be logged in with valid credentials",
            "User must belong to the company",
            "User must be member of the team to view repositories",
            "Team name filtering with exact case-sensitive match",
            "Multiple teams supported with comma-separated names",
            "No team specified returns repositories from all your teams",
            "Shows repository name, GUID, and parent repository ID",
            "Vault data decrypted using company passphrase",
            "Results sorted by team name then repository name",
            "Three-level access control: authentication, company, team"
          ]
        }
      },
      "team-storages": {
        "endpoint": "GetTeamStorages",
        "params": "lambda args: {'teamName': args.team}",
        "help": {
          "description": "List storage resources for a team",
          "details": "Shows all external storage configurations for a team. Storage resources represent S3 buckets, Azure Blob Storage, or network shares used for backups and data exchange.",
          "parameters": {
            "team": {
              "description": "Team name to list storages from",
              "required": true,
              "example": "data-team"
            }
          },
          "examples": [
            {
              "command": "rediacc list team-storages data-team",
              "description": "List all storage resources in data-team"
            },
            {
              "command": "rediacc list team-storages backup --output json | jq '.[] | select(.storageName | contains(\"s3\"))'",
              "description": "Find all S3 storage resources"
            }
          ],
          "notes": "You must be a member of the team. Storage credentials are encrypted in vaults. Used with repo_push/repo_pull functions.",
          "rules": [
            "User must be logged in with valid credentials",
            "User account must be activated",
            "Can only access storage from your own company",
            "Must be member of the team to view storage",
            "Maintenance mode blocks non-administrator access",
            "Team name filtering supports comma-separated values",
            "Shows storage name, team, and decrypted configuration",
            "Storage credentials automatically decrypted",
            "Results sorted by team name then storage name",
            "Failed authentication results in 403 error"
          ]
        }
      },
      "list-system-configuration": {
        "endpoint": "GetSystemConfiguration",
        "params": "lambda args: {'configKey': args.config_key}",
        "help": {
          "parameters": {
            "config_key": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-user-vault": {
        "endpoint": "GetUserVault",
        "params": "lambda args: {}"
      }
    },
    "rm": {
      "team": {
        "endpoint": "DeleteTeam",
        "params": "lambda args: {'teamName': args.name}",
        "confirm_msg": "Are you sure you want to delete team '{name}'? This will remove all resources in the team.",
        "success_msg": "Successfully deleted team: {name}",
        "help": {
          "description": "Delete a team and all its resources",
          "details": "Permanently removes a team and all associated resources including machines, repositories, storages, and schedules. This action cannot be undone.",
          "parameters": {
            "name": {
              "description": "Name of the team to delete",
              "required": true,
              "example": "old-team"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc rm team old-team",
              "description": "Delete team with confirmation"
            },
            {
              "command": "rediacc rm team old-team --force",
              "description": "Delete team without confirmation"
            }
          ],
          "notes": "WARNING: This cascades to all team resources. Ensure data is backed up. Requires team ownership or admin permissions.",
          "rules": [
            "You must be logged in with valid credentials",
            "You must be a member of the team to delete it",
            "Team must belong to your company",
            "'Private Team' cannot be deleted (system requirement)",
            "Cannot delete the last team in a company",
            "Team must have no machines before deletion",
            "Team must have no repositories before deletion",
            "Team must have no schedules before deletion",
            "Team must have no storage configurations before deletion",
            "Deletion removes all memberships, vault data, and audit logs are created"
          ]
        }
      },
      "machine": {
        "endpoint": "DeleteMachine",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.name}",
        "confirm_msg": "Are you sure you want to delete machine '{name}' from team '{team}'?",
        "success_msg": "Successfully deleted machine: {name}",
        "help": {
          "description": "Delete a machine from a team",
          "details": "Permanently removes a machine configuration. Does not affect the actual server, only removes it from the Rediacc system. Pending queue items will fail.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "dev-team"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc rm machine dev-team old-server",
              "description": "Delete machine with confirmation"
            },
            {
              "command": "rediacc rm machine staging temp-machine --force",
              "description": "Delete without confirmation"
            }
          ],
          "notes": "Check for pending queue items before deletion. The actual server is not affected. Consider updating vault to mark as decommissioned instead of deleting.",
          "rules": [
            "You must be logged in with valid user account",
            "Must belong to the same company that owns the machine",
            "Must be an active member of the team that owns the machine",
            "Machine must exist in the specified team",
            "Cannot delete if machine has pending queue items",
            "Deletion removes machine configuration and vault data",
            "Action cannot be undone",
            "Every deletion is logged in audit trail",
            "No special admin privileges required beyond team membership",
            "Actual server is not affected, only Rediacc configuration removed"
          ]
        }
      },
      "bridge": {
        "endpoint": "DeleteBridge",
        "params": "lambda args: {'regionName': args.region, 'bridgeName': args.name}",
        "confirm_msg": "Are you sure you want to delete bridge '{name}' from region '{region}'?",
        "success_msg": "Successfully deleted bridge: {name}",
        "help": {
          "description": "Delete a bridge from a region",
          "details": "Removes a bridge configuration. Ensure no machines are assigned to this bridge and no queue items are pending. Running bridge processes should be stopped first.",
          "parameters": {
            "region": {
              "description": "Region containing the bridge",
              "required": true,
              "example": "us-east"
            },
            "bridge": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc rm bridge us-east old-bridge",
              "description": "Delete bridge with confirmation"
            },
            {
              "command": "rediacc rm bridge europe decommissioned-bridge --force",
              "description": "Force delete without confirmation"
            }
          ],
          "notes": "Cannot delete if machines are assigned. Reassign machines first using 'update machine-bridge'. Stop bridge process before deletion.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must belong to the same company as the bridge",
            "Bridge name must exist in the specified region",
            "Bridge must not be assigned to any machines",
            "Bridge must not have active queue items in PENDING or ASSIGNED states",
            "Cannot delete bridges currently processing queue items",
            "Only bridges with FAILED, COMPLETED, or CANCELLED queue items can be deleted",
            "Deletion will also remove all bridge vault data",
            "Operation is permanent and cannot be undone",
            "Bridge deletion is tracked in audit logs for compliance"
          ]
        }
      },
      "region": {
        "endpoint": "DeleteRegion",
        "params": "lambda args: {'regionName': args.name}",
        "confirm_msg": "Are you sure you want to delete region '{name}'? This will remove all bridges in the region.",
        "success_msg": "Successfully deleted region: {name}",
        "help": {
          "description": "Delete a region and all its bridges",
          "details": "Removes a region and cascades deletion to all bridges within it. Ensure no machines are assigned to bridges in this region. This is a destructive operation.",
          "parameters": {
            "name": {
              "description": "Region name to delete",
              "required": true,
              "example": "old-region"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc rm region test-region",
              "description": "Delete region with confirmation"
            },
            {
              "command": "rediacc rm region deprecated-region --force",
              "description": "Force delete without confirmation"
            }
          ],
          "notes": "WARNING: Cascades to all bridges in the region. Cannot delete if bridges have assigned machines. Clear all dependencies first.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must belong to the same company as the region",
            "Region name must exist in the system",
            "Region must not contain any bridges",
            "Region must not be referenced by any machines",
            "Cannot delete regions with active infrastructure",
            "All bridges must be deleted or moved before region deletion",
            "Region vault data will be permanently removed",
            "Operation is permanent and cannot be undone",
            "Region deletion is tracked in audit logs for compliance"
          ]
        }
      },
      "repository": {
        "endpoint": "DeleteRepository",
        "params": "lambda args: {'teamName': args.team, 'repoName': args.repository}",
        "confirm_msg": "Are you sure you want to delete repository '{name}' from team '{team}'?",
        "success_msg": "Successfully deleted repository: {name}",
        "help": {
          "description": "Delete a repository from the system",
          "details": "Permanently removes a repository and all its data. The repository's Docker containers will be stopped, volumes unmounted, and all associated data deleted. This action cannot be undone.",
          "parameters": {
            "team": {
              "help": "Team that owns the repository",
              "required": true
            },
            "repository": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc rm repository old-app --team dev",
              "description": "Delete repository with confirmation"
            },
            {
              "command": "rediacc rm repository temp-test --team qa --force",
              "description": "Force delete without confirmation"
            }
          ],
          "notes": "Ensure all data is backed up before deletion. Running containers will be stopped. Consider using repo_down first.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Repository must exist within the team",
            "Repository must be offline (not currently mounted)",
            "Repository must not have active backup or restore operations",
            "Cannot delete repositories referenced in active schedules",
            "All associated repository vault data will be deleted",
            "Repository files on disk will be permanently removed",
            "Operation is permanent and cannot be undone",
            "Repository deletion is tracked in audit logs"
          ]
        }
      },
      "storage": {
        "endpoint": "DeleteStorage",
        "params": "lambda args: {'teamName': args.team, 'storageName': args.storage}",
        "confirm_msg": "Are you sure you want to delete storage '{name}' from team '{team}'?",
        "success_msg": "Successfully deleted storage: {name}",
        "help": {
          "description": "Delete a storage configuration from the system",
          "details": "Removes a storage configuration including credentials and settings. Does not delete actual data in the external storage system (S3, Azure, etc.), only the Rediacc configuration.",
          "parameters": {
            "team": {
              "help": "Team that owns the storage",
              "required": true
            },
            "storage": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc rm storage old-backup --team ops",
              "description": "Delete storage config with confirmation"
            },
            {
              "command": "rediacc rm storage temp-s3 --team dev --force",
              "description": "Force delete without confirmation"
            }
          ],
          "notes": "Only removes Rediacc configuration. Data in external storage systems remains untouched. Update any schedules using this storage.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Storage configuration must exist within the team",
            "Storage must not be referenced in active backup schedules",
            "Storage must not have ongoing transfer operations",
            "Cannot delete storage with active repository backups",
            "All associated storage vault data will be deleted",
            "Cloud storage data is not deleted, only the configuration",
            "Operation is permanent and cannot be undone",
            "Storage deletion is tracked in audit logs"
          ]
        }
      },
      "queue-item": {
        "endpoint": "DeleteQueueItem",
        "params": "lambda args: {'taskId': args.task_id}",
        "confirm_msg": "Are you sure you want to delete queue item '{task_id}'?",
        "success_msg": "Successfully deleted queue item: {task_id}",
        "help": {
          "description": "Delete a queue item from the system",
          "details": "Removes a pending queue item to prevent execution. Only PENDING or CANCELLED items can be deleted. Running or completed items cannot be removed for audit purposes.",
          "parameters": {
            "taskid": {
              "help": "Task ID of the queue item to delete",
              "required": true,
              "positional": true
            },
            "task_id": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc rm queue-item 550e8400-e29b-41d4-a716-446655440000",
              "description": "Delete queue item with confirmation"
            },
            {
              "command": "rediacc rm queue-item 550e8400 --force",
              "description": "Force delete using partial task ID"
            }
          ],
          "notes": "Cannot delete running or completed items. Use 'queue cancel' for running tasks. Deletion is immediate and permanent.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must have access to the team that created the queue item",
            "Queue item must exist with the specified task ID",
            "Can only delete items in PENDING or CANCELLED states",
            "Cannot delete items in ASSIGNED or PROCESSING states",
            "Cannot delete COMPLETED or FAILED items (kept for audit)",
            "Deletion prevents the task from being executed",
            "Associated queue vault data will be removed",
            "Operation is permanent and cannot be undone",
            "Queue item deletion is tracked in audit logs"
          ]
        }
      }
    },
    "bridge": {
      "reset-auth": {
        "endpoint": "ResetBridgeAuthorization",
        "params": "lambda args: {'bridgeName': args.name, 'isCloudManaged': args.cloud_managed}",
        "confirm_msg": "Are you sure you want to reset authorization for bridge '{name}'? This will generate new credentials.",
        "success_msg": "Successfully reset authorization for bridge: {name}",
        "help": {
          "description": "Generate new bridge credentials",
          "details": "Resets the authentication credentials for a bridge. The running bridge process will need to be restarted with new credentials.",
          "parameters": {
            "name": {
              "description": "Bridge name to reset",
              "required": true,
              "example": "main-bridge"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            },
            "cloud_managed": {
              "description": "",
              "required": false,
              "example": ""
            },
            "bridge": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must belong to the same company as the bridge",
            "Bridge must exist in the system",
            "Old authentication token will be immediately invalidated",
            "New token is generated using cryptographically secure randomness",
            "Bridge must be restarted with the new token to reconnect",
            "Active bridge connections will be terminated",
            "Any running tasks on the bridge will need to be retried",
            "Token reset is tracked in audit logs for security",
            "New token must be securely transmitted to bridge operator"
          ]
        }
      },
      "update-bridge-vault": {
        "endpoint": "UpdateBridgeVault",
        "params": "lambda args: {'regionName': args.region, 'bridgeName': args.name, 'bridgeVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "region": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "bridge": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "update": {
      "team": {
        "endpoint": "UpdateTeamName",
        "params": "lambda args: {'currentTeamName': args.current_team_name, 'newTeamName': args.new_name}",
        "success_msg": "Successfully updated team name: {name} → {new_name}",
        "help": {
          "description": "Rename a team",
          "details": "Changes the name of an existing team. All resources remain associated with the team. References in scripts and configurations must be updated manually.",
          "parameters": {
            "new_name": {
              "description": "New team name (must be unique)",
              "required": true,
              "example": "new-team-name"
            },
            "current_team_name": {
              "description": "",
              "required": true,
              "example": ""
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the team being renamed",
            "Current team name must exist in the company",
            "New team name must be unique within the company",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "Team memberships and permissions are preserved",
            "All references to the team are automatically updated",
            "Team vault data remains unchanged",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "region": {
        "endpoint": "UpdateRegionName",
        "params": "lambda args: {'currentRegionName': args.current_region_name, 'newRegionName': args.new_name}",
        "success_msg": "Successfully updated region name: {name} → {new_name}",
        "help": {
          "description": "Rename a region",
          "details": "Changes the name of an existing region. All bridges within the region remain associated. Update any scripts or configurations that reference the old name.",
          "parameters": {
            "new_name": {
              "description": "New region name (must be unique)",
              "required": true,
              "example": "new-region"
            },
            "current_region_name": {
              "description": "",
              "required": true,
              "example": ""
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must belong to the same company as the region",
            "Current region name must exist in the company",
            "New region name must be unique within the company",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "All bridges in the region remain associated",
            "Machine assignments to the region are preserved",
            "Region vault data remains unchanged",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "bridge": {
        "endpoint": "UpdateBridgeName",
        "params": "lambda args: {'regionName': args.region, 'currentBridgeName': args.current_bridge_name, 'newBridgeName': args.new_name}",
        "success_msg": "Successfully updated bridge name: {name} → {new_name}",
        "help": {
          "description": "Rename a bridge",
          "details": "Changes the name of an existing bridge within a region. Machine assignments remain unchanged. Running bridge processes are not affected.",
          "parameters": {
            "region": {
              "description": "Region containing the bridge",
              "required": true,
              "example": "us-east"
            },
            "current_bridge_name": {
              "description": "",
              "required": true,
              "example": ""
            },
            "new_name": {
              "description": "New bridge name (unique within region)",
              "required": true,
              "example": "new-bridge"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must belong to the same company as the bridge",
            "Current bridge name must exist in the region",
            "New bridge name must be unique within the region",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "Bridge authentication token remains unchanged",
            "Machine assignments to the bridge are preserved",
            "Active connections are not interrupted",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "machine": {
        "endpoint": "UpdateMachineName",
        "params": "lambda args: {'teamName': args.team, 'currentMachineName': args.current_machine_name, 'newMachineName': args.new_name}",
        "success_msg": "Successfully updated machine name: {name} → {new_name}",
        "help": {
          "description": "Rename a machine",
          "details": "Changes the name of an existing machine. The new name must be unique across the entire company. Active queue items continue processing.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "production-team"
            },
            "current_machine_name": {
              "description": "",
              "required": true,
              "example": ""
            },
            "new_name": {
              "description": "New machine name (company-wide unique)",
              "required": true,
              "example": "new-server"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Current machine name must exist within the team",
            "New machine name must be unique within the team",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "Machine status and bridge assignment remain unchanged",
            "SSH connection settings are preserved",
            "Repository associations are maintained",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "machine-bridge": {
        "endpoint": "UpdateMachineAssignedBridge",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.name, 'newBridgeName': args.new_bridge}",
        "success_msg": "Successfully updated machine bridge: {name} → {new_bridge}",
        "help": {
          "description": "Reassign a machine to a different bridge",
          "details": "Changes which bridge processes queue items for a machine. Useful for load balancing, maintenance, or moving machines between regions. Pending queue items remain with the original bridge.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "production-team"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "new_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "new_bridge": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc update machine-bridge prod db-01 us-west-bridge",
              "description": "Move machine to different bridge"
            },
            {
              "command": "rediacc update machine-bridge dev test-server local-bridge",
              "description": "Reassign test server to local bridge"
            }
          ],
          "notes": "New queue items will be processed by the new bridge. Existing items in PENDING state remain with original bridge. Consider queue state before reassigning.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Machine must exist within the team",
            "Bridge must exist and belong to the same company",
            "Bridge and machine must be in the same region",
            "Bridge must be in an active state",
            "Previous bridge assignment will be removed",
            "Active tasks may need to be rescheduled",
            "Machine remains accessible through new bridge",
            "Assignment change is tracked in audit logs"
          ]
        }
      },
      "repository": {
        "endpoint": "UpdateRepositoryName",
        "params": "lambda args: {'teamName': args.team, 'currentRepoName': args.current_repo_name, 'newRepoName': args.new_name}",
        "success_msg": "Successfully updated repository name: {name} → {new_name}",
        "help": {
          "description": "Rename a repository",
          "details": "Changes the name of an existing repository within a team. Repository data and configurations are preserved. Update deployment scripts that reference the old name.",
          "parameters": {
            "team": {
              "description": "Team that owns the repository",
              "required": true,
              "example": "dev-team"
            },
            "current_repo_name": {
              "description": "",
              "required": true,
              "example": ""
            },
            "new_name": {
              "description": "New repository name (unique within team)",
              "required": true,
              "example": "new-app"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Current repository name must exist within the team",
            "New repository name must be unique within the team",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "Repository must be offline during rename",
            "Physical files are not renamed, only the reference",
            "Schedule references are automatically updated",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "repository-vault": {
        "endpoint": "UpdateRepositoryVault",
        "params": "lambda args: {'teamName': args.team, 'repoName': args.repository, 'repoVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Successfully updated repository vault: {name}",
        "help": {
          "description": "Update repository configuration vault",
          "details": "Updates the encrypted configuration data for a repository. Used to modify repository settings, environment variables, deployment configurations, and secrets.",
          "parameters": {
            "team": {
              "description": "Team that owns the repository",
              "required": true,
              "example": "dev-team"
            },
            "vault": {
              "description": "JSON configuration data",
              "required": false,
              "example": "{\"size\": \"20G\", \"env\": {\"NODE_ENV\": \"production\"}}"
            },
            "repository": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc update repository-vault dev web-app --vault '{\"size\":\"30G\"}'",
              "description": "Update repository size"
            },
            {
              "command": "rediacc update repository-vault prod api --vault-file new-config.json",
              "description": "Update repository config from file"
            }
          ],
          "notes": "Vault data is encrypted. Changes may require repository restart. Use 'inspect repository' to see current vault.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Repository must exist within the team",
            "Vault data must be valid JSON format",
            "Vault data is encrypted before storage",
            "Maximum vault size is 64KB after encryption",
            "Previous vault data is overwritten",
            "Repository configuration like size and mount options can be updated",
            "Changes take effect on next repository mount",
            "Vault update is tracked in audit logs"
          ]
        }
      },
      "storage": {
        "endpoint": "UpdateStorageName",
        "params": "lambda args: {'teamName': args.team, 'currentStorageName': args.current_storage_name, 'newStorageName': args.new_name}",
        "success_msg": "Successfully updated storage name: {name} → {new_name}",
        "help": {
          "description": "Rename a storage resource",
          "details": "Changes the name of an existing storage configuration. The actual storage backend (S3 bucket, Azure container, etc.) is not affected.",
          "parameters": {
            "team": {
              "description": "Team that owns the storage",
              "required": true,
              "example": "backup-team"
            },
            "current_storage_name": {
              "description": "",
              "required": true,
              "example": ""
            },
            "new_name": {
              "description": "New storage name (unique within team)",
              "required": true,
              "example": "new-backup"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Current storage name must exist within the team",
            "New storage name must be unique within the team",
            "New name must be between 1 and 50 characters",
            "New name cannot be empty or only whitespace",
            "Storage connection settings remain unchanged",
            "Schedule references are automatically updated",
            "Active backup operations are not affected",
            "Name change is tracked in audit logs"
          ]
        }
      },
      "storage-vault": {
        "endpoint": "UpdateStorageVault",
        "params": "lambda args: {'teamName': args.team, 'storageName': args.storage, 'storageVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Successfully updated storage vault: {name}",
        "help": {
          "description": "Update storage credentials and configuration",
          "details": "Updates the encrypted vault containing storage credentials and settings. Used to change access keys, endpoints, or storage parameters.",
          "parameters": {
            "team": {
              "description": "Team that owns the storage",
              "required": true,
              "example": "backup-team"
            },
            "vault": {
              "description": "JSON with storage credentials and config",
              "required": false,
              "example": "{\"type\": \"s3\", \"bucket\": \"backups\", \"access_key\": \"...\", \"secret_key\": \"...\"}"
            },
            "storage": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc update storage-vault backup s3-main --vault-file new-creds.json",
              "description": "Update S3 credentials from file"
            },
            {
              "command": "rediacc update storage-vault data azure-storage --vault '{\"container\":\"new-container\"}'",
              "description": "Change Azure container"
            }
          ],
          "notes": "Credentials are encrypted. Test access after updating. Supports S3, Azure Blob, GCS, SFTP, and SMB.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team",
            "Storage configuration must exist within the team",
            "Vault data must be valid JSON format",
            "Vault data is encrypted before storage",
            "Maximum vault size is 64KB after encryption",
            "Cloud storage credentials can be updated",
            "Connection strings and API keys must be valid",
            "Changes take effect on next backup operation",
            "Vault update is tracked in audit logs"
          ]
        }
      },
      "machine-status": {
        "endpoint": "UpdateMachineStatus",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.name, 'machineStatus': args.status}",
        "success_msg": "Successfully updated machine status: {name}",
        "help": {
          "description": "Update the status of a machine",
          "details": "Sets a custom status message for a machine, useful for maintenance windows, debugging, or operational notes. The status is displayed in machine listings.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "production-team"
            },
            "status": {
              "description": "",
              "required": true,
              "example": ""
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User must be authenticated to perform this operation",
            "User must be a member of the specified team OR be a bridge that owns at least one machine in the same team",
            "Machine must exist within the team",
            "Status must be one of: online, offline, maintenance, error",
            "Status change affects task scheduling",
            "Offline machines will not receive new tasks",
            "Maintenance status prevents automatic task assignment",
            "Error status indicates machine needs attention",
            "Status changes are immediately reflected in scheduling",
            "Status update is tracked in audit logs",
            "Bridges can update status of any machine in teams where they own at least one machine"
          ]
        }
      }
    },
    "vault": {
      "set": {
        "endpoints": {
          "team": "UpdateTeamVault",
          "machine": "UpdateMachineVault",
          "region": "UpdateRegionVault",
          "bridge": "UpdateBridgeVault",
          "company": "UpdateCompanyVault",
          "repository": "UpdateRepositoryVault",
          "storage": "UpdateStorageVault",
          "schedule": "UpdateScheduleVault"
        },
        "params": "lambda args: get_vault_set_params(args)",
        "success_msg": "Successfully updated {resource_type} vault",
        "help": {
          "description": "Update vault data for any resource type",
          "details": "Updates the encrypted vault configuration for teams, machines, regions, bridges, company, repositories, storages, or schedules. Vaults store sensitive configuration data and credentials.",
          "parameters": {
            "resource_type": {
              "description": "Type of resource to update",
              "required": true,
              "example": "machine",
              "choices": [
                "team",
                "machine",
                "region",
                "bridge",
                "company",
                "repository",
                "storage",
                "schedule"
              ]
            },
            "name": {
              "description": "Resource name (not needed for 'company')",
              "required": false,
              "example": "web-server-01"
            },
            "file": {
              "description": "File containing JSON vault data (use '-' for stdin)",
              "required": false,
              "example": "vault-config.json"
            },
            "team": {
              "description": "Team name (required for machine, repository, storage, schedule)",
              "required": false,
              "example": "dev-team"
            },
            "region": {
              "description": "Region name (required for bridge)",
              "required": false,
              "example": "us-east"
            },
            "vault-version": {
              "description": "Vault schema version",
              "required": false,
              "example": "2"
            }
          },
          "examples": [
            {
              "command": "rediacc vault set machine web-01 machine-config.json --team prod",
              "description": "Update machine vault from file"
            },
            {
              "command": "echo '{\"SSH_PRIVATE_KEY\":\"...\"}' | rediacc vault set team dev-team -",
              "description": "Update team vault from stdin"
            },
            {
              "command": "rediacc vault set company company-settings.json",
              "description": "Update company-wide vault"
            }
          ],
          "notes": "Vault data is encrypted with master password. Always backup current vault before updating. Use 'inspect' commands to view current vault.",
          "rules": [
            "User must be authenticated to perform this operation",
            "User must have appropriate access to the entity",
            "Vault data must be valid JSON format",
            "Vault data is encrypted with master password before storage",
            "Maximum vault size is 64KB after encryption",
            "Company vault requires company admin permissions",
            "Team vault requires team membership",
            "Entity-specific vaults require team membership",
            "Previous vault data is completely replaced",
            "Vault updates are tracked in audit logs for security"
          ]
        }
      },
      "set-password": {
        "help": {
          "description": "Set the master password for vault encryption",
          "details": "Configures the master password used to encrypt and decrypt all vault data. This password is stored locally and never transmitted. Required for vault operations.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc vault set-password",
              "description": "Set master password with secure prompt"
            }
          ],
          "notes": "Password is stored in local configuration. Use a strong password. Required for viewing/updating vault data.",
          "rules": [
            "This is a local client-side operation (no server API call)",
            "The password is stored only in memory during the current CLI session",
            "Password is never saved to disk or configuration files",
            "Required to decrypt vault data returned from API responses",
            "Password remains in memory until CLI exits or you use clear-password",
            "Each company may have its own master password",
            "Wrong password will result in garbled vault data when decrypting",
            "Password input is hidden for security (no echo to terminal)",
            "No password complexity requirements enforced by the client",
            "Used for both encryption and decryption of vault fields"
          ]
        }
      },
      "clear-password": {
        "help": {
          "description": "Clear the stored master password",
          "details": "Removes the master password from local configuration. You'll need to re-enter it for future vault operations.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc vault clear-password",
              "description": "Remove stored master password"
            }
          ],
          "notes": "Use this for security when done with vault operations. Does not affect encrypted data.",
          "rules": [
            "This is a local client-side operation (no server API call)",
            "Only clears the password from current CLI session memory",
            "Does not affect other CLI sessions or users",
            "Vault fields will show as encrypted base64 strings after clearing",
            "You can set the password again anytime with vault set-password",
            "Clearing does not log you out or affect authentication",
            "Executes immediately without confirmation prompt",
            "Automatically happens when you exit the CLI or logout",
            "Useful for security when sharing terminal or taking a break",
            "Does not modify any encrypted data stored on the server"
          ]
        }
      },
      "status": {
        "help": {
          "description": "Show vault encryption status",
          "details": "Displays whether a master password is configured and provides information about vault encryption status.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc vault status",
              "description": "Check vault configuration status"
            }
          ],
          "notes": "Shows if master password is set but not the password itself.",
          "rules": [
            "This is primarily a local operation with one API call if needed",
            "User must be authenticated to check vault status",
            "Automatically fetches company vault info if not cached",
            "Shows if cryptography library is installed locally",
            "Displays current company name from authentication",
            "Indicates if company requires vault encryption",
            "Shows if master password is set in current session",
            "Read-only operation that doesn't modify any data",
            "Helps troubleshoot vault access issues",
            "Supports JSON output mode for scripting"
          ]
        }
      }
    },
    "distributed-storage": {
      "create-cluster": {
        "endpoint": "CreateDistributedStorageCluster",
        "params": "lambda args: {'clusterName': args.cluster, 'clusterVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully created distributed storage cluster: {name} for team {team}",
        "help": {
          "description": "Create a distributed storage cluster",
          "details": "Creates a cluster configuration for distributed storage across multiple machines. Enables redundant storage with automatic replication and failover.",
          "parameters": {
            "vault": {
              "description": "JSON configuration for the cluster",
              "required": false,
              "example": "{\"replication_factor\": 3, \"storage_class\": \"ssd\"}"
            },
            "vault-file": {
              "description": "File containing JSON vault data",
              "required": false,
              "example": "cluster-config.json"
            },
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User must be authenticated with valid credentials",
            "User must be a member of the specified team",
            "Cluster name must be unique within the team",
            "Team must exist in your company",
            "Cluster configuration requires specific parameters in vault data",
            "Pool PG number must be between 1 and 1024",
            "New clusters start with PENDING status",
            "No subscription plan restrictions for creating clusters",
            "Vault data is encrypted using company master password",
            "Cluster creation is logged in audit trail"
          ]
        }
      },
      "delete-cluster": {
        "endpoint": "DeleteDistributedStorageCluster",
        "params": "lambda args: {'clusterName': args.cluster}",
        "confirm_msg": "Are you sure you want to delete distributed storage cluster '{name}' from team '{team}'?",
        "success_msg": "Successfully deleted distributed storage cluster: {name}",
        "help": {
          "description": "Delete a distributed storage cluster",
          "details": "Permanently removes a distributed storage cluster configuration. Does not delete data on machines, only the cluster configuration.",
          "parameters": {
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            },
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User must be authenticated with valid credentials",
            "User must be either an administrator or team member",
            "Cluster must exist in the specified team",
            "Cluster must have zero nodes before deletion",
            "Cannot delete cluster with machines still attached",
            "Deletion removes cluster configuration and credentials",
            "Associated vault data is automatically cleaned up",
            "Machine distributed storage flags remain unchanged",
            "Operation is permanent and cannot be undone",
            "Deletion is logged in audit trail for compliance"
          ]
        }
      },
      "update-vault": {
        "endpoint": "UpdateDistributedStorageClusterVault",
        "params": "lambda args: {'clusterName': args.cluster, 'clusterVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Successfully updated distributed storage cluster vault: {cluster}",
        "help": {
          "description": "Update cluster configuration vault",
          "details": "Updates the encrypted configuration for a distributed storage cluster including replication settings, storage policies, and performance parameters.",
          "parameters": {
            "cluster": {
              "description": "Cluster name",
              "required": true,
              "example": "main-cluster"
            },
            "vault": {
              "description": "JSON configuration data",
              "required": false,
              "example": "{\"replication_factor\": 3, \"consistency_level\": \"strong\"}"
            },
            "vault-file": {
              "description": "File containing JSON vault data",
              "required": false,
              "example": "cluster-config.json"
            },
            "vault-version": {
              "description": "Vault schema version (default: 1)",
              "required": false,
              "example": "2"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "User must be authenticated with valid credentials",
            "User must be a member of the team owning the cluster",
            "Cluster must exist before updating vault",
            "Vault data must be provided as text (cannot be empty)",
            "Maximum vault chunk size is 3,072 characters",
            "Large vaults automatically split into multiple chunks",
            "Vault data is encrypted with company master password",
            "Each update increments vault version number",
            "Previous vault data is completely replaced",
            "Update is logged in audit trail"
          ]
        }
      },
      "update-machine-distributed-storage": {
        "endpoint": "UpdateMachineDistributedStorage",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.machine, 'clusterName': args.cluster}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "create-distributed-storage-rbd-image": {
        "endpoint": "CreateDistributedStorageRbdImage",
        "params": "lambda args: {'poolName': args.pool, 'teamName': args.team, 'imageName': args.image, 'imageVault': get_vault_data(args) or '{}', 'machineName': args.machine}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-clusters": {
        "endpoint": "GetDistributedStorageClusters",
        "params": "lambda args: {}",
        "success_msg": "Operation completed successfully"
      },
      "delete-distributed-storage-rbd-image": {
        "endpoint": "DeleteDistributedStorageRbdImage",
        "params": "lambda args: {'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "create-distributed-storage-rbd-clone": {
        "endpoint": "CreateDistributedStorageRbdClone",
        "params": "lambda args: {'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team, 'cloneName': args.clone, 'cloneVault': get_vault_data(args) or '{}'}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "clone": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-rbd-snapshots": {
        "endpoint": "GetDistributedStorageRbdSnapshots",
        "params": "lambda args: {'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-rbd-clones": {
        "endpoint": "GetDistributedStorageRbdClones",
        "params": "lambda args: {'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "create-distributed-storage-pool": {
        "endpoint": "CreateDistributedStoragePool",
        "params": "lambda args: {'clusterName': args.cluster, 'teamName': args.team, 'poolName': args.pool, 'poolVault': get_vault_data(args) or '{}'}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-rbd-images": {
        "endpoint": "GetDistributedStorageRbdImages",
        "params": "lambda args: {'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "create-distributed-storage-rbd-snapshot": {
        "endpoint": "CreateDistributedStorageRbdSnapshot",
        "params": "lambda args: {'imageName': args.image, 'poolName': args.pool, 'teamName': args.team, 'snapshotName': args.snapshot, 'snapshotVault': get_vault_data(args) or '{}'}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "delete-distributed-storage-rbd-clone": {
        "endpoint": "DeleteDistributedStorageRbdClone",
        "params": "lambda args: {'cloneName': args.clone, 'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "clone": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "delete-distributed-storage-pool": {
        "endpoint": "DeleteDistributedStoragePool",
        "params": "lambda args: {'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-pools": {
        "endpoint": "GetDistributedStoragePools",
        "params": "lambda args: {'teamName': args.team, 'clusterName': args.cluster}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-distributed-storage-cluster-machines": {
        "endpoint": "GetDistributedStorageClusterMachines",
        "params": "lambda args: {'clusterName': args.cluster}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-distributed-storage-pool-vault": {
        "endpoint": "UpdateDistributedStoragePoolVault",
        "params": "lambda args: {'poolName': args.pool, 'teamName': args.team, 'poolVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "delete-distributed-storage-rbd-snapshot": {
        "endpoint": "DeleteDistributedStorageRbdSnapshot",
        "params": "lambda args: {'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "permission": {
      "create-group": {
        "endpoint": "CreatePermissionGroup",
        "params": "lambda args: {'permissionGroupName': args.name}",
        "success_msg": "Successfully created permission group: {name}",
        "help": {
          "description": "Create a new permission group",
          "details": "Creates a permission group that can be assigned to users. Permission groups control access to API endpoints and system features.",
          "parameters": {
            "name": {
              "description": "Unique name for the permission group",
              "required": true,
              "example": "developers"
            }
          },
          "examples": [
            {
              "command": "rediacc permission create-group developers",
              "description": "Create a developers permission group"
            },
            {
              "command": "rediacc permission create-group read-only",
              "description": "Create a read-only access group"
            }
          ],
          "notes": "Requires admin permissions. Group names must be unique within the company. Add permissions after creation.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Custom groups require paid subscription (Advanced, Premium, or Elite)",
            "Community plan users cannot create custom permission groups",
            "Group name must be unique within your company",
            "Cannot use reserved names: Administrators, Users, or Bridges",
            "Maximum group name length is 100 characters",
            "Group name cannot be empty or only whitespace",
            "Any authenticated user can create groups (with paid plan)",
            "New groups start empty with no permissions",
            "Group creation is logged in audit trail"
          ]
        }
      },
      "delete-group": {
        "endpoint": "DeletePermissionGroup",
        "params": "lambda args: {'permissionGroupName': args.name}",
        "confirm_msg": "Are you sure you want to delete permission group '{name}'?",
        "success_msg": "Successfully deleted permission group: {name}",
        "help": {
          "description": "Delete a permission group",
          "details": "Permanently removes a permission group. Users assigned to this group will lose those permissions.",
          "parameters": {
            "name": {
              "description": "Permission group name to delete",
              "required": true,
              "example": "old-group"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc permission delete-group temporary-access",
              "description": "Delete group with confirmation"
            },
            {
              "command": "rediacc permission delete-group test-group --force",
              "description": "Delete without confirmation"
            }
          ],
          "notes": "Cannot delete system groups. Check user assignments before deletion. This is irreversible.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Cannot delete system groups: Administrators, Users, or Bridges",
            "Group must not have any users assigned to it",
            "Group must not be used by any active sessions",
            "Only custom permission groups can be deleted",
            "All permissions within the group are permanently removed",
            "Deletion works on any subscription plan (including Community)",
            "Group must exist in your company",
            "Operation is permanent and cannot be undone",
            "Deletion is logged in audit trail"
          ]
        }
      },
      "add": {
        "endpoint": "CreatePermissionInGroup",
        "params": "lambda args: {'permissionGroupName': args.group, 'permissionName': args.name}",
        "success_msg": "Successfully added permission: {name} to group {group}",
        "help": {
          "description": "Add permission to a group",
          "details": "Grants a specific API endpoint permission to a permission group. Users in the group gain access to that endpoint.",
          "parameters": {
            "group": {
              "description": "Permission group to modify",
              "required": true,
              "example": "developers"
            },
            "name": {
              "description": "Permission name (API endpoint)",
              "required": true,
              "example": "CreateMachine"
            }
          },
          "examples": [
            {
              "command": "rediacc permission add developers CreateMachine",
              "description": "Allow developers to create machines"
            },
            {
              "command": "rediacc permission add read-only GetTeamMachines",
              "description": "Allow read-only users to list machines"
            }
          ],
          "notes": "Permission names correspond to API endpoints. Use 'list lookup-data' to see available permissions.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Permission group must exist in your company",
            "Cannot add permissions to Administrators group (has all permissions)",
            "Cannot add permissions to Bridges group (protected system group)",
            "Permission must be a valid system permission name",
            "Cannot add duplicate permissions to a group",
            "Only custom groups can have permissions added",
            "Permission names must match approved API endpoints",
            "Each addition is logged in audit trail",
            "Company boundaries are strictly enforced"
          ]
        }
      },
      "remove": {
        "endpoint": "DeletePermissionFromGroup",
        "params": "lambda args: {'permissionGroupName': args.group, 'permissionName': args.name}",
        "confirm_msg": "Are you sure you want to remove permission '{name}' from group '{group}'?",
        "success_msg": "Successfully removed permission: {name} from group {group}",
        "help": {
          "description": "Remove permission from a group",
          "details": "Revokes a specific API endpoint permission from a permission group. Users in the group lose access to that endpoint.",
          "parameters": {
            "group": {
              "description": "Permission group to modify",
              "required": true,
              "example": "developers"
            },
            "name": {
              "description": "Permission name to remove",
              "required": true,
              "example": "DeleteMachine"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc permission remove developers DeleteMachine",
              "description": "Revoke machine deletion from developers"
            },
            {
              "command": "rediacc permission remove contractors CreateBridge --force",
              "description": "Remove permission without confirmation"
            }
          ],
          "notes": "Takes effect immediately for all users in the group. Use 'list-group' to see current permissions.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Permission group must exist in your company",
            "Cannot modify Administrators group (protected)",
            "Cannot modify Bridges group (protected)",
            "Permission must exist in the specified group",
            "Users group can have permissions removed",
            "Users immediately lose access to removed function",
            "Change takes effect without requiring re-login",
            "Removal is permanent and logged in audit trail",
            "Only appropriate admin privileges allow this operation"
          ]
        }
      },
      "assign": {
        "endpoint": "UpdateUserAssignedPermissions",
        "params": "lambda args: {'userEmail': args.user_email, 'permissionGroupName': args.group}",
        "success_msg": "Successfully assigned permission group {group} to user {email}",
        "help": {
          "description": "Assign permission group to user",
          "details": "Changes a user's permission group, granting them all permissions associated with that group. Users can only belong to one permission group.",
          "parameters": {
            "group": {
              "description": "Permission group to assign",
              "required": true,
              "example": "developers"
            },
            "user_email": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc permission assign john@company.com developers",
              "description": "Give John developer permissions"
            },
            {
              "command": "rediacc permission assign contractor@external.com read-only",
              "description": "Limit contractor to read-only access"
            }
          ],
          "notes": "Replaces user's current permission group. Changes take effect on next login. Requires admin permissions.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Target user must exist in your company",
            "Permission group must exist in your company",
            "Can only assign groups with equal or fewer privileges",
            "Only administrators can assign users to Bridges group",
            "Cannot remove last active administrator from company",
            "Changes take effect immediately for active sessions",
            "Higher privilege tokens are automatically downgraded",
            "Assignment is logged with token modification count",
            "Users can only belong to one permission group"
          ]
        }
      },
      "list-groups": {
        "endpoint": "GetCompanyPermissionGroups",
        "params": "lambda args: {}",
        "help": {
          "description": "List all permission groups",
          "details": "Shows all permission groups in the company including system groups and custom groups. Displays group names and member counts.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc permission list-groups",
              "description": "Display all permission groups"
            },
            {
              "command": "rediacc permission list-groups --output json",
              "description": "Get groups in JSON format"
            }
          ],
          "notes": "System groups like 'Admins' and 'Bridges' cannot be modified. Shows user count for each group.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Only administrators can view permission groups",
            "Shows all groups for your company (system and custom)",
            "Displays group name, user count, and permission count",
            "Lists all permissions for each group",
            "Results sorted alphabetically by group name",
            "No filtering or pagination available",
            "Maintenance mode blocks non-admin access",
            "Operation is company-specific",
            "Failed attempts are logged for security"
          ]
        }
      },
      "list-group": {
        "endpoint": "GetPermissionGroupDetails",
        "params": "lambda args: {'permissionGroupName': args.name}",
        "help": {
          "description": "Show permissions in a specific group",
          "details": "Lists all API endpoint permissions granted to a permission group. Shows which operations users in this group can perform.",
          "parameters": {
            "name": {
              "description": "Permission group name",
              "required": true,
              "example": "developers"
            }
          },
          "examples": [
            {
              "command": "rediacc permission list-group developers",
              "description": "Show all permissions for developers"
            },
            {
              "command": "rediacc permission list-group Admins --output json",
              "description": "List admin permissions in JSON"
            }
          ],
          "notes": "Permission names correspond to API endpoints. Compare groups to understand access levels.",
          "rules": [
            "User must be authenticated with valid credentials",
            "Only administrators can view group details",
            "Group must exist in your company",
            "Shows all permissions in the group alphabetically",
            "Group names are case-sensitive",
            "Works for both system and custom groups",
            "No limit on permissions displayed",
            "Company-specific access only",
            "Access attempts are tracked for security",
            "Returns error if group doesn't exist"
          ]
        }
      }
    },
    "company": {
      "block-user-requests": {
        "endpoint": "UpdateCompanyBlockUserRequests",
        "params": "lambda args: {'blockUserRequests': args.block}",
        "success_msg": "Successfully updated company user request blocking: {block}",
        "help": {
          "description": "Block or unblock new user registration requests",
          "details": "Controls whether new users can request accounts in your company. When blocked, only administrators can create new user accounts directly.",
          "parameters": {
            "block": {
              "description": "Block user requests (true/false)",
              "required": true,
              "example": "true"
            }
          },
          "examples": [
            {
              "command": "rediacc company block-user-requests true",
              "description": "Block new user registrations"
            },
            {
              "command": "rediacc company block-user-requests false",
              "description": "Allow new user registrations"
            }
          ],
          "notes": "Requires company admin permissions. Existing users are not affected. Useful during maintenance or to control company growth.",
          "rules": [
            "Must be authenticated with company administrator permissions",
            "When blocked, self-registration on login page is disabled",
            "Administrators can still create users manually",
            "Does not affect existing user accounts or active sessions",
            "Change takes effect immediately for new requests",
            "Pending user requests remain in queue when blocking is enabled",
            "Useful for controlling company user growth",
            "Can be toggled on/off as needed without data loss",
            "Setting is stored at company level",
            "Change is logged in audit trail"
          ]
        }
      },
      "update-vault": {
        "endpoint": "UpdateCompanyVault",
        "params": "lambda args: {'companyVault': get_vault_data(args) or '{}', 'vaultVersion': getattr(args, 'vault_version', 1)}",
        "success_msg": "Successfully updated company vault",
        "help": {
          "description": "Update company-wide vault configuration",
          "details": "Updates the encrypted vault containing company-wide settings, credentials, and configuration that apply to all teams and users.",
          "parameters": {
            "vault": {
              "description": "JSON vault data to store",
              "required": false,
              "example": "{\"UNIVERSAL_USER_NAME\": \"system\", \"API_KEY\": \"abc123\"}"
            },
            "vault-file": {
              "description": "File containing JSON vault data",
              "required": false,
              "example": "company-vault.json"
            },
            "vault-version": {
              "description": "Vault schema version",
              "required": false,
              "example": "2"
            }
          },
          "examples": [
            {
              "command": "rediacc company update-vault --vault-file company-config.json",
              "description": "Update from configuration file"
            },
            {
              "command": "rediacc company update-vault --vault '{\"UNIVERSAL_USER_NAME\":\"rediacc\"}'",
              "description": "Update specific vault field"
            }
          ],
          "notes": "Requires company admin permissions. Vault data is encrypted with master password. Changes affect all teams.",
          "rules": [
            "Must be authenticated with company administrator permissions",
            "Vault data must be valid JSON format",
            "Maximum vault size is 64KB after encryption",
            "Vault is encrypted with company master password",
            "Previous vault contents are completely replaced",
            "Common fields: UNIVERSAL_USER_NAME, UNIVERSAL_USER_ID",
            "Changes propagate to all teams and users",
            "Vault version helps with schema migrations",
            "Update is tracked in audit logs",
            "Cannot be undone - backup before updating"
          ]
        }
      },
      "get-vaults": {
        "endpoint": "GetCompanyVaults",
        "params": "lambda args: {}",
        "help": {
          "description": "Retrieve all company vault data",
          "details": "Fetches all vault configurations stored at the company level, including encrypted settings and credentials. Useful for backup or inspection.",
          "examples": [
            {
              "command": "rediacc company get-vaults",
              "description": "Display all company vaults"
            },
            {
              "command": "rediacc company get-vaults --output json > backup.json",
              "description": "Backup vaults to file"
            }
          ],
          "notes": "Requires company admin permissions. Vault data is returned encrypted unless master password is set.",
          "rules": [
            "Must be authenticated with company administrator permissions",
            "Returns all vault data stored at company level",
            "Vault data remains encrypted in response",
            "Decryption requires master password to be set",
            "Includes vault version information",
            "Useful for backup before major changes",
            "Can export to JSON for archival",
            "Access is logged in audit trail",
            "Response may be large for companies with extensive configs",
            "Read-only operation with no side effects"
          ]
        }
      },
      "update-vaults": {
        "endpoint": "UpdateCompanyVaults",
        "params": "lambda args: {'updates': args.updates}",
        "success_msg": "Successfully updated company vaults",
        "help": {
          "description": "Bulk update multiple company vaults",
          "details": "Updates multiple vault configurations at once. Useful for restoring from backup or migrating settings.",
          "parameters": {
            "vault": {
              "description": "JSON object containing multiple vaults",
              "required": false,
              "example": "{\"primary\": {...}, \"secondary\": {...}}"
            },
            "vault-file": {
              "description": "File containing JSON vaults data",
              "required": false,
              "example": "all-vaults.json"
            },
            "updates": {
              "description": "",
              "required": true,
              "example": ""
            }
          },
          "rules": [
            "User must be authenticated with valid credentials",
            "Only administrators can update company vaults",
            "Bulk updates multiple vaults in single operation",
            "User login attempts blocked during update",
            "Cannot update if company has Global Bridge with cloud management",
            "All vaults must belong to entities within your company",
            "Cannot update vault if newer version exists",
            "TFA vaults cannot be updated through this operation",
            "Either all updates succeed or none are applied",
            "Updates are logged with count of vaults modified"
          ]
        }
      },
      "export-data": {
        "endpoint": "ExportCompanyData",
        "params": "lambda args: {}",
        "success_msg": "Successfully exported company data",
        "help": {
          "description": "Export all company data to JSON format",
          "details": "Exports complete company configuration including teams, users, permissions, regions, bridges, and machines. Vault data is included in encrypted form.",
          "parameters": {},
          "examples": [
            {
              "command": "rediacc company export-data > company-backup.json",
              "description": "Export company data to file"
            },
            {
              "command": "rediacc company export-data | jq '.teams'",
              "description": "View exported teams data"
            }
          ],
          "notes": "Requires admin permissions. Export includes all entity configurations and relationships. Vault data remains encrypted.",
          "rules": [
            "Must be authenticated with administrator permissions",
            "Exports all company entities and configurations",
            "Vault data is included in encrypted form",
            "Export can be large for companies with many resources",
            "Includes timestamps and version information",
            "Useful for backup before major changes",
            "Can be used with import-data for migration",
            "Operation is logged in audit trail"
          ]
        }
      },
      "import-data": {
        "endpoint": "ImportCompanyData",
        "params": "lambda args: {'companyDataJson': get_vault_data(args) or '{}', 'importMode': getattr(args, 'import_mode', 'skip')}",
        "success_msg": "Successfully imported company data",
        "help": {
          "description": "Import company data from JSON",
          "details": "Imports company configuration from a previously exported JSON file. Supports skip mode (default) which skips existing entities, or override mode which updates existing entities.",
          "parameters": {
            "vault-file": {
              "description": "File containing exported company data",
              "required": true,
              "example": "company-backup.json"
            },
            "import-mode": {
              "description": "Import mode: skip or override",
              "required": false,
              "example": "override",
              "default": "skip"
            }
          },
          "examples": [
            {
              "command": "rediacc company import-data --vault-file backup.json",
              "description": "Import with skip mode (default)"
            },
            {
              "command": "rediacc company import-data --vault-file backup.json --import-mode override",
              "description": "Import with override mode"
            }
          ],
          "notes": "Requires admin permissions. Skip mode preserves existing data. Override mode updates existing entities. Always backup before importing.",
          "rules": [
            "Must be authenticated with administrator permissions",
            "Import data must be from same or compatible version",
            "Skip mode: existing entities are preserved",
            "Override mode: existing entities are updated",
            "Cannot import if company passphrase has changed",
            "User accounts must match email addresses",
            "Import creates audit log entries",
            "Partial imports may occur if errors encountered",
            "Vault data must be compatible with current passphrase"
          ]
        }
      }
    },
    "audit": {
      "trace": {
        "endpoint": "GetEntityAuditTrace",
        "params": "lambda args: {'entityType': args.entity_type, 'entityIdentifier': args.entity_identifier}",
        "help": {
          "description": "Get detailed audit trail for entity",
          "details": "Retrieves comprehensive audit information for a specific entity including all changes, access logs, and related operations.",
          "parameters": {
            "entity_type": {
              "description": "",
              "required": true,
              "example": ""
            },
            "entity_identifier": {
              "description": "",
              "required": true,
              "example": ""
            }
          },
          "rules": [
            "User must be authenticated with valid credentials",
            "Regular users can only view their own audit history",
            "Team members can view audit for team resources",
            "Administrators can view all company entity audits",
            "Audit retention varies by subscription tier (7-365 days)",
            "Maximum 100 records shown at once",
            "Sensitive operations masked for non-administrators",
            "Entity must exist and belong to your company",
            "Region, bridge, permissions require admin access",
            "Results sorted newest to oldest"
          ]
        }
      }
    },
    "user": {
      "activate": {
        "auth_required": false,
        "auth_type": "credentials",
        "endpoint": "ActivateUserAccount",
        "params": "lambda args: {'activationCode': args.code or TEST_ACTIVATION_CODE}",
        "success_msg": "Successfully activated user: {email}",
        "help": {
          "description": "Activate a user account",
          "details": "Activates a newly created user account using an activation code. Users must be activated before they can log in. Default code is 111111 for testing.",
          "parameters": {
            "email": {
              "description": "Email address of user to activate",
              "required": true,
              "example": "newuser@company.com"
            },
            "code": {
              "description": "Activation code (default: 111111)",
              "required": false,
              "example": "123456"
            }
          },
          "examples": [
            {
              "command": "rediacc user activate newuser@company.com",
              "description": "Activate with default code"
            },
            {
              "command": "rediacc user activate admin@company.com --code 654321",
              "description": "Activate with custom code"
            }
          ],
          "notes": "No authentication required for activation. Activation codes are set during user creation. Users receive activation instructions via email if configured.",
          "rules": [
            "No authentication required for this operation",
            "Activation code must be exactly 6 characters long",
            "Code comparison is case-insensitive",
            "Email must match an existing user account",
            "User must not already be activated",
            "Activation code is deleted after successful use",
            "Account becomes active and can log in",
            "User can join teams after activation",
            "Counts toward company's active user limit",
            "Activation is logged in audit trail"
          ]
        }
      },
      "deactivate": {
        "endpoint": "UpdateUserToDeactivated",
        "params": "lambda args: {'userEmail': args.email}",
        "confirm_msg": "Are you sure you want to deactivate user '{email}'?",
        "success_msg": "Successfully deactivated user: {email}",
        "help": {
          "description": "Deactivate a user account",
          "details": "Deactivates a user account, preventing login while preserving all data and history. The account can be reactivated later if needed.",
          "parameters": {
            "email": {
              "description": "Email address of user to deactivate",
              "required": true,
              "example": "user@company.com"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc user deactivate employee@company.com",
              "description": "Deactivate with confirmation"
            },
            {
              "command": "rediacc user deactivate contractor@company.com --force",
              "description": "Deactivate without confirmation"
            }
          ],
          "notes": "Deactivated users cannot log in but their data is preserved. Use for employees who leave. Can be reactivated.",
          "rules": [
            "Requires user management or admin permissions",
            "Cannot deactivate your own account",
            "Cannot deactivate the last admin user",
            "User's active sessions are terminated",
            "User immediately loses all access",
            "All team memberships are preserved",
            "User's data and history remain intact",
            "Account can be reactivated with user activate",
            "Deactivation is logged in audit trail",
            "Pending tasks assigned to user continue"
          ]
        }
      },
      "update-email": {
        "endpoint": "UpdateUserEmail",
        "params": "lambda args: {'currentUserEmail': args.current_email, 'newUserEmail': args.new_email}",
        "success_msg": "Successfully updated user email: {current_email} → {new_email}",
        "help": {
          "description": "Change a user's email address",
          "details": "Updates a user's email address across the system. The new email becomes the login identifier. All permissions and data are preserved.",
          "parameters": {
            "current_email": {
              "description": "Current email address",
              "required": true,
              "example": "old@company.com"
            },
            "new_email": {
              "description": "New email address",
              "required": true,
              "example": "new@company.com"
            }
          },
          "examples": [
            {
              "command": "rediacc user update-email old@company.com new@company.com",
              "description": "Change user's email"
            },
            {
              "command": "rediacc user update-email jane.doe@company.com jane.smith@company.com",
              "description": "Update email after name change"
            }
          ],
          "notes": "New email must be unique. User must log in with new email after change. Consider notifying the user.",
          "rules": [
            "Requires user management or admin permissions",
            "New email must not already exist in system",
            "New email must be valid email format",
            "Cannot change email to one from different company domain",
            "User's active sessions remain valid",
            "All permissions and team memberships preserved",
            "Audit history updated with both emails",
            "User must use new email for future logins",
            "Change notification sent to both email addresses",
            "Email change is logged in audit trail"
          ]
        }
      },
      "update-password": {
        "endpoint": "UpdateUserPassword",
        "params": "lambda args: {'userNewPass': pwd_hash(args.new_password)}",
        "success_msg": "Successfully updated user password",
        "help": {
          "description": "Change your password",
          "details": "Updates the password for the currently authenticated user. The new password is hashed before transmission. You'll need to re-authenticate after changing.",
          "parameters": {
            "new-password": {
              "description": "New password (will be prompted if not provided)",
              "required": true,
              "example": "SecureP@ssw0rd!"
            }
          },
          "examples": [
            {
              "command": "rediacc user update-password",
              "description": "Change password with secure prompt"
            },
            {
              "command": "rediacc user update-password --new-password 'MyN3wP@ssw0rd!'",
              "description": "Change password directly (less secure)"
            }
          ],
          "notes": "Requires current authentication. Password requirements depend on company policy. After change, all sessions are invalidated - you must log in again.",
          "rules": [
            "User must be authenticated with valid session",
            "Session-based identity verification (no current password needed)",
            "New password must be provided as 32-byte hash",
            "Password is encrypted with company passphrase",
            "Change takes effect immediately",
            "Current session remains active (not logged out)",
            "Other sessions remain valid until expiration",
            "Account must be activated to change password",
            "No password complexity rules enforced by system",
            "Password change is logged in audit trail"
          ]
        }
      }
    },
    "auth": {
      "status": {
        "endpoint": "GetRequestAuthenticationStatus",
        "params": "lambda args: {'requestHash': args.request_hash}",
        "help": {
          "description": "Check authentication request status",
          "details": "Queries the status of a pending authentication request by its hash. Used to verify if an authentication attempt succeeded.",
          "parameters": {
            "request_hash": {
              "description": "Authentication request hash",
              "required": true,
              "example": "a1b2c3d4e5f6..."
            }
          },
          "examples": [
            {
              "command": "rediacc auth status a1b2c3d4e5f6789",
              "description": "Check status of auth request"
            }
          ],
          "notes": "Request hashes are provided during login attempts. Status includes pending, authorized, or expired.",
          "rules": [
            "Requires active authentication token to display status",
            "Shows current user email, company, and assigned teams",
            "Displays token creation time and expiration status",
            "Lists all permission groups assigned to the user",
            "Shows whether TFA is enabled for the account",
            "Indicates if account is activated or pending activation",
            "Returns error if no valid token is present",
            "Token details include the token ID (not the full token value)",
            "Useful for verifying session validity before operations",
            "Does not refresh or extend token lifetime"
          ]
        }
      },
      "privilege": {
        "endpoint": "PrivilegeAuthenticationRequest",
        "params": "lambda args: {'tFACode': args.t_f_a_code}",
        "success_msg": "Successfully privileged authentication request",
        "help": {
          "description": "Grant special privileges to auth request",
          "details": "Elevates an authentication request with special privileges. Used for administrative operations requiring enhanced permissions.",
          "parameters": {
            "2_f_a_code": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "t_f_a_code": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "rules": [
            "Only available to users with privilege escalation permissions",
            "May require re-entering password for security verification",
            "Elevated privileges are temporary and session-specific",
            "Privilege elevation is logged in audit trail",
            "Cannot escalate beyond maximum assigned permission level",
            "Some operations may require approval from another admin",
            "Elevation automatically expires after timeout period",
            "Failed elevation attempts are logged and may trigger alerts",
            "Cannot be used to bypass company-level restrictions",
            "Revoked immediately if suspicious activity is detected"
          ]
        }
      }
    },
    "team-member": {
      "add": {
        "endpoint": "CreateTeamMembership",
        "params": "lambda args: {'teamName': args.team, 'newUserEmail': args.new_user_email}",
        "success_msg": "Successfully added {email} to team {team}",
        "help": {
          "description": "Add user to team",
          "details": "Grants a user membership in a team, giving them access to all team resources including machines, repositories, and storages.",
          "parameters": {
            "team": {
              "description": "Team name",
              "required": true,
              "example": "dev-team"
            },
            "new_user_email": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc team-member add dev-team john@company.com",
              "description": "Add John to development team"
            },
            {
              "command": "rediacc team-member add production admin@company.com",
              "description": "Add admin to production team"
            }
          ],
          "notes": "User must exist and be activated. You must be a team member to add others. Changes take effect immediately.",
          "rules": [
            "Requires team admin or company admin permissions",
            "User must already have an account in the company",
            "User must have activated their account",
            "Cannot add users from other companies",
            "Users can be members of multiple teams",
            "Team role determines permissions within that team only",
            "Adding as Admin grants full control over team resources",
            "Member role provides read and basic write access",
            "Operation is logged in audit trail",
            "Triggers notification email to the added user"
          ]
        }
      },
      "remove": {
        "endpoint": "DeleteUserFromTeam",
        "params": "lambda args: {'teamName': args.team, 'removeUserEmail': args.remove_user_email}",
        "confirm_msg": "Are you sure you want to remove '{email}' from team '{team}'?",
        "success_msg": "Successfully removed {email} from team {team}",
        "help": {
          "description": "Remove user from team",
          "details": "Revokes a user's team membership, removing their access to all team resources. The user remains in the company.",
          "parameters": {
            "team": {
              "description": "Team name",
              "required": true,
              "example": "dev-team"
            },
            "remove_user_email": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          },
          "examples": [
            {
              "command": "rediacc team-member remove dev-team contractor@external.com",
              "description": "Remove contractor with confirmation"
            },
            {
              "command": "rediacc team-member remove production ex-employee@company.com --force",
              "description": "Force remove without confirmation"
            }
          ],
          "notes": "Cannot remove last team member. User loses access immediately. Consider impact on active work.",
          "rules": [
            "Requires team admin or company admin permissions",
            "Cannot remove the last admin from a team",
            "User immediately loses access to all team resources",
            "Active sessions for team resources are terminated",
            "Does not delete the user account from the company",
            "User can be re-added to the team later if needed",
            "Removal is logged in audit trail",
            "Any running operations by the user continue to completion",
            "User's personal data and contributions are preserved",
            "Triggers notification email to the removed user"
          ]
        }
      }
    },
    "queue": {
      "get-next": {
        "endpoint": "GetQueueItemsNext",
        "params": "lambda args: {'itemCount': args.count or 3}",
        "help": {
          "description": "Get next queue items for processing",
          "details": "Retrieves and assigns the next available queue items to the caller. Used by bridges to fetch work. Items are automatically marked as ASSIGNED.",
          "parameters": {
            "count": {
              "description": "Number of items to retrieve (default: 3)",
              "required": false,
              "example": "5"
            }
          },
          "examples": [
            {
              "command": "rediacc queue get-next",
              "description": "Get next 3 items (default)"
            },
            {
              "command": "rediacc queue get-next --count 10",
              "description": "Get up to 10 items"
            }
          ],
          "notes": "Designed for bridges. Items are assigned to caller's identity. Returns empty array if no items available.",
          "rules": [
            "Requires bridge or administrative authentication",
            "Returns only PENDING items from accessible teams",
            "Items are immediately marked as ASSIGNED",
            "Assignment prevents other bridges from taking items",
            "Respects queue priority ordering (1 is highest)",
            "Maximum count is typically limited to 10",
            "Returns fewer items if not enough available",
            "Caller identity is recorded on assigned items",
            "Items expire if not completed within timeout",
            "Load balances across available bridges"
          ]
        }
      },
      "list": {
        "endpoint": "GetTeamQueueItems",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.machine, 'bridgeName': args.bridge, 'status': args.status, 'priority': args.priority, 'minPriority': args.min_priority, 'maxPriority': args.max_priority, 'dateFrom': args.date_from, 'dateTo': args.date_to, 'taskId': args.task_id, 'includeCompleted': args.include_completed, 'includeCancelled': args.include_cancelled, 'onlyStale': args.only_stale, 'staleThresholdMinutes': args.stale_threshold_minutes, 'maxRecords': args.max_records, 'createdByUserEmail': args.created_by_user_email}",
        "help": {
          "description": "List queue items with various filters",
          "details": "View queue items across teams with powerful filtering options. Monitor task status, find stuck items, analyze performance, and track execution history.",
          "parameters": {
            "team": {
              "description": "Filter by team name(s), comma-separated",
              "required": false,
              "example": "prod,staging"
            },
            "machine": {
              "description": "Filter by specific machine",
              "required": false,
              "example": "web-server-01"
            },
            "bridge": {
              "description": "Filter by specific bridge",
              "required": false,
              "example": "us-east-bridge"
            },
            "status": {
              "description": "Filter by status (PENDING,ASSIGNED,PROCESSING,COMPLETED,FAILED,CANCELLED)",
              "required": false,
              "example": "PENDING,PROCESSING"
            },
            "priority": {
              "description": "Filter by exact priority (1-5)",
              "required": false,
              "example": "1"
            },
            "created_by_user_email": {
              "description": "",
              "required": true,
              "example": ""
            },
            "min_priority": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "max_priority": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "date_from": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "date_to": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "task_id": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "include_completed": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "include_cancelled": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "only_stale": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "stale_threshold_minutes": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "max_records": {
              "description": "",
              "required": true,
              "example": "",
              "type": "integer"
            }
          },
          "rules": [
            "Requires team member or higher permissions",
            "Shows queue items for specified team only",
            "Default limit is 100 items, use --limit to change",
            "Items are sorted by creation time (newest first)",
            "Can filter by status: PENDING, ASSIGNED, PROCESSING, COMPLETED, FAILED",
            "Can filter by specific machine or bridge",
            "Completed items are retained for 30 days",
            "Shows task ID, status, priority, and timestamps",
            "Response data is decrypted if master password is set",
            "High-priority items (1-2) are highlighted in output"
          ]
        }
      },
      "update-response": {
        "endpoint": "UpdateQueueItemResponse",
        "params": "lambda args: {'taskId': args.task_id, 'responseVault': get_vault_data(args) or '{}'}",
        "success_msg": "Successfully updated queue item response: {task_id}",
        "help": {
          "description": "Update progress/status of a processing queue item",
          "details": "Updates a queue item with intermediate results or progress information while it's being processed. Used by bridges to report progress.",
          "parameters": {
            "task_id": {
              "description": "Task ID (GUID) to update",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            },
            "vault": {
              "description": "JSON progress data",
              "required": false,
              "example": "{\"progress\": 50, \"status\": \"Processing file 2 of 4\"}"
            }
          },
          "examples": [
            {
              "command": "rediacc queue update-response 550e8400 --vault '{\"progress\":25}'",
              "description": "Update task progress to 25%"
            },
            {
              "command": "rediacc queue update-response 550e8400 --vault-file status.json",
              "description": "Update from status file"
            }
          ],
          "notes": "Used by bridges during task execution. Can be called multiple times. Does not change task state.",
          "rules": [
            "Requires bridge or administrative authentication",
            "Task must be assigned to caller (for bridges)",
            "Task must be in ASSIGNED or PROCESSING state",
            "Response vault is encrypted before storage",
            "Updates are appended to task history",
            "Does not change overall task status",
            "Useful for long-running operations",
            "Each update includes timestamp",
            "Previous responses are preserved",
            "Can be used to stream output data"
          ]
        }
      },
      "complete": {
        "endpoint": "UpdateQueueItemToCompleted",
        "params": "lambda args: {'taskId': args.task_id, 'finalVault': get_vault_data(args) or '{}', 'finalStatus': args.final_status}",
        "success_msg": "Successfully completed queue item: {task_id}",
        "help": {
          "description": "Mark a queue item as completed",
          "details": "Marks a processing queue item as successfully completed with optional result data. Used by bridges to finalize task execution.",
          "parameters": {
            "task_id": {
              "description": "Task ID (GUID) to complete",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            },
            "vault": {
              "description": "JSON result data to store",
              "required": false,
              "example": "{\"status\": \"success\", \"output\": \"Task completed\"}"
            },
            "final_status": {
              "description": "",
              "required": true,
              "example": ""
            }
          },
          "rules": [
            "Requires authentication with appropriate permissions",
            "Task must exist and belong to accessible team",
            "Task must be in PROCESSING or ASSIGNED state",
            "Cannot complete already COMPLETED or FAILED tasks",
            "Final vault data is encrypted before storage",
            "Completion time is recorded automatically",
            "Status changes to COMPLETED immediately",
            "Triggers any dependent operations",
            "Completion is logged in task history",
            "Bridge that processed task is recorded"
          ]
        }
      },
      "trace": {
        "endpoint": "GetQueueItemTrace",
        "params": "lambda args: {'taskId': args.task_id}",
        "help": {
          "description": "Get execution trace for a queue item",
          "details": "Retrieves detailed execution history and logs for a specific queue item, including all state changes, assignments, and bridge interactions.",
          "parameters": {
            "task_id": {
              "description": "Task ID (GUID) to trace",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            }
          },
          "examples": [
            {
              "command": "rediacc queue trace 550e8400-e29b-41d4-a716-446655440000",
              "description": "Get full trace for task"
            },
            {
              "command": "rediacc queue trace 550e8400 --output json | jq '.logs'",
              "description": "Extract logs from trace"
            }
          ],
          "notes": "Shows complete task lifecycle. Useful for debugging failed tasks or monitoring execution progress.",
          "rules": [
            "Requires team member or higher permissions",
            "Task must belong to accessible team",
            "Shows all state transitions with timestamps",
            "Includes bridge assignment history",
            "Contains any error messages or stack traces",
            "Shows intermediate responses from updates",
            "Displays retry attempts if any",
            "Includes cancellation information if cancelled",
            "Vault data shown if master password is set",
            "Access is logged in audit trail"
          ]
        }
      },
      "cancel": {
        "endpoint": "CancelQueueItem",
        "params": "lambda args: {'taskId': args.task_id}",
        "confirm_msg": "Are you sure you want to cancel queue item '{task_id}'?",
        "success_msg": "Successfully cancelled queue item: {task_id}",
        "help": {
          "description": "Cancel a pending or processing queue item",
          "details": "Marks a queue item as cancelled, preventing further processing. If already processing, the bridge will attempt to stop execution gracefully. Completed items cannot be cancelled.",
          "parameters": {
            "task_id": {
              "description": "Task ID (GUID) to cancel",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            },
            "force": {
              "description": "Skip confirmation prompt",
              "required": false,
              "example": "--force"
            }
          },
          "examples": [
            {
              "command": "rediacc queue cancel 550e8400-e29b-41d4-a716-446655440000",
              "description": "Cancel with confirmation"
            },
            {
              "command": "rediacc queue cancel 550e8400-e29b-41d4-a716-446655440000 --force",
              "description": "Cancel without confirmation"
            }
          ],
          "notes": "Cancellation is immediate for PENDING items. PROCESSING items may continue briefly while the bridge stops gracefully. Check status after cancelling.",
          "rules": [
            "Requires team member or higher permissions",
            "Can only cancel items from your team's queue",
            "Cannot cancel COMPLETED or FAILED items",
            "PENDING items are cancelled immediately",
            "ASSIGNED items are unassigned from bridge",
            "PROCESSING items receive cancellation signal",
            "Bridge may complete current operation before stopping",
            "Cancelled items are marked with CANCELLED status",
            "Cancellation is logged in queue item history",
            "Associated resources may need manual cleanup"
          ]
        }
      },
      "retry": {
        "endpoint": "RetryFailedQueueItem",
        "params": "lambda args: {'taskId': args.task_id}",
        "success_msg": "Successfully retried queue item: {task_id}",
        "help": {
          "description": "Retry a failed queue item",
          "details": "Creates a new queue item with the same configuration as a failed item. The original item's status remains FAILED. Useful for transient failures or after fixing issues.",
          "parameters": {
            "task_id": {
              "description": "Task ID (GUID) of failed item to retry",
              "required": true,
              "example": "550e8400-e29b-41d4-a716-446655440000"
            }
          },
          "examples": [
            {
              "command": "rediacc queue retry 550e8400-e29b-41d4-a716-446655440000",
              "description": "Retry a failed task"
            },
            {
              "command": "rediacc queue list --status FAILED --output json | jq -r '.[].taskId' | xargs -I {} rediacc queue retry {}",
              "description": "Retry all failed tasks"
            }
          ],
          "notes": "Only FAILED items can be retried. Creates a new item with same priority and configuration. Check failure reason before retrying to avoid repeated failures.",
          "rules": [
            "Requires team member or higher permissions",
            "Can only retry FAILED or CANCELLED items",
            "Original item must belong to your team",
            "Creates new queue item with fresh task ID",
            "Copies all parameters from original item",
            "Resets retry count to zero",
            "New item gets default priority unless specified",
            "Original failed item is not modified",
            "Links to original item for audit trail",
            "May fail again if underlying issue not resolved"
          ]
        }
      }
    },
    "inspect": {
      "machine": {
        "endpoint": "GetTeamMachines",
        "params": "lambda args: {'teamName': args.team}",
        "filter": "lambda data, args: [m for m in data if m.get('machineName') == args.name]",
        "single_result": true,
        "help": {
          "description": "Get detailed information about a machine",
          "details": "Shows comprehensive information about a specific machine including its configuration, status, assigned bridge, and decrypted vault data.",
          "parameters": {
            "team": {
              "description": "Team that owns the machine",
              "required": true,
              "example": "production"
            },
            "name": {
              "description": "Machine name",
              "required": true,
              "example": "web-server-01"
            }
          },
          "examples": [
            {
              "command": "rediacc inspect machine prod web-01",
              "description": "Inspect production web server"
            },
            {
              "command": "rediacc inspect machine dev database --output json",
              "description": "Get machine details in JSON format"
            }
          ],
          "notes": "Shows decrypted vault if master password is set. Includes IP address, SSH credentials, and custom configuration.",
          "rules": [
            "Requires team member or higher permissions",
            "Machine must belong to specified team",
            "Shows machine GUID and creation timestamp",
            "Displays current status and assigned bridge",
            "Vault data is decrypted if master password is set",
            "Machine names are case-insensitive for lookup",
            "Shows SSH connection details from vault",
            "Includes datastore path configuration",
            "Reveals all custom fields in machine vault",
            "Access is logged in audit trail"
          ]
        }
      },
      "repository": {
        "endpoint": "GetTeamRepositories",
        "params": "lambda args: {'teamName': args.team}",
        "filter": "lambda data, args: [r for r in data if r.get('repoName') == args.name]",
        "single_result": true,
        "help": {
          "description": "Get detailed info about a repository",
          "details": "Shows comprehensive information about a specific repository including vault configuration, size, and settings.",
          "parameters": {
            "team": {
              "description": "Team that owns the repository",
              "required": true,
              "example": "dev-team"
            },
            "name": {
              "description": "Repository name",
              "required": true,
              "example": "web-app"
            }
          },
          "examples": [
            {
              "command": "rediacc inspect repository dev-team web-app",
              "description": "Inspect web-app repository"
            },
            {
              "command": "rediacc inspect repository prod api --output json",
              "description": "Get repository details in JSON"
            }
          ],
          "notes": "Shows decrypted vault if master password is set. Includes size, type, and configuration details.",
          "rules": [
            "Requires team member or higher permissions",
            "Repository must belong to specified team",
            "Shows repository GUID and creation timestamp",
            "Displays associated machine and its status",
            "Vault data is decrypted if master password is set",
            "Repository names are case-insensitive for lookup",
            "Shows Docker configuration if present in vault",
            "Includes mount paths and datastore locations",
            "Reveals environment variables stored in vault",
            "Access is logged in audit trail"
          ]
        }
      }
    },
    "clone": {
      "update-clone-machine-removals": {
        "endpoint": "UpdateCloneMachineRemovals",
        "params": "lambda args: {'cloneName': args.clone, 'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team, 'machineNames': args.machine_names}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "clone": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine_names": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-available-machines-for-clone": {
        "endpoint": "GetAvailableMachinesForClone",
        "params": "lambda args: {'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-clone-machine-assignments": {
        "endpoint": "UpdateCloneMachineAssignments",
        "params": "lambda args: {'cloneName': args.clone, 'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team, 'machineNames': args.machine_names}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "clone": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine_names": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-clone-machine-assignment-validation": {
        "endpoint": "GetCloneMachineAssignmentValidation",
        "params": "lambda args: {'teamName': args.team, 'machineNames': args.machine_names}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine_names": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-clone-machines": {
        "endpoint": "GetCloneMachines",
        "params": "lambda args: {'cloneName': args.clone, 'snapshotName': args.snapshot, 'imageName': args.image, 'poolName': args.pool, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "clone": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "snapshot": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "machine": {
      "update-machine-vault": {
        "endpoint": "UpdateMachineVault",
        "params": "lambda args: {'teamName': args.team, 'machineName': args.machine, 'machineVault': get_vault_data(args) or '{}', 'vaultVersion': args.vault_version}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-machine-cluster-removal": {
        "endpoint": "UpdateMachineClusterRemoval",
        "params": "lambda args: {'machineName': args.machine, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "list-machine-assignment-status": {
        "endpoint": "GetMachineAssignmentStatus",
        "params": "lambda args: {'machineName': args.machine, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-machine-cluster-assignment": {
        "endpoint": "UpdateMachineClusterAssignment",
        "params": "lambda args: {'clusterName': args.cluster, 'machineName': args.machine, 'teamName': args.team}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "cluster": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "machine": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "region": {
      "update-region-vault": {
        "endpoint": "UpdateRegionVault",
        "params": "lambda args: {'regionName': args.region, 'regionVault': args.vault, 'vaultVersion': args.vault_version}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "region": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "misc": {
      "update-image-machine-assignment": {
        "endpoint": "UpdateImageMachineAssignment",
        "params": "lambda args: {'imageName': args.image, 'poolName': args.pool, 'teamName': args.team, 'newMachineName': args.new_name}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "image": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "pool": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "new_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "is-registered": {
        "endpoint": "IsRegistered",
        "params": "lambda args: {'userName': args.user_name}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "user_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-user2-f-a": {
        "endpoint": "UpdateUserTFA",
        "params": "lambda args: {'enable': args.enable, 'userHash': args.user_hash, 'currentCode': args.current_code, 'generateOnly': args.generate_only, 'verificationCode': args.verification_code, 'secret': args.secret, 'confirmEnable': args.confirm_enable}",
        "help": {
          "parameters": {
            "enable": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "user_hash": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "current_code": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "generate_only": {
              "description": "",
              "required": true,
              "example": "",
              "type": "boolean"
            },
            "verification_code": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "secret": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "confirm_enable": {
              "description": "",
              "required": true,
              "example": "",
              "type": "boolean"
            }
          }
        }
      },
      "fork-authentication-request": {
        "endpoint": "ForkAuthenticationRequest",
        "params": "lambda args: {'childName': args.child_name, 'tokenExpirationHours': args.token_expiration_hours}",
        "help": {
          "parameters": {
            "child_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "token_expiration_hours": {
              "description": "",
              "required": true,
              "example": "",
              "type": "integer"
            }
          }
        }
      },
      "promote-repository-to-grand": {
        "endpoint": "PromoteRepositoryToGrand",
        "params": "lambda args: {'teamName': args.team, 'repoName': args.repo_name}",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "repo_name": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            }
          }
        }
      },
      "update-user-vault": {
        "endpoint": "UpdateUserVault",
        "params": "lambda args: {'userVault': args.vault, 'vaultVersion': args.vault_version}",
        "help": {
          "parameters": {
            "vault": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    },
    "team": {
      "update-team-vault": {
        "endpoint": "UpdateTeamVault",
        "params": "lambda args: {'teamName': args.team, 'teamVault': args.vault, 'vaultVersion': args.vault_version}",
        "success_msg": "Operation completed successfully",
        "help": {
          "parameters": {
            "team": {
              "description": "",
              "required": true,
              "example": "",
              "type": "string"
            },
            "vault": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            },
            "vault_version": {
              "description": "",
              "required": false,
              "example": "",
              "type": "string"
            }
          }
        }
      }
    }
  },
  "CLI_COMMANDS": {
    "license": {
      "description": "License management commands",
      "subcommands": {
        "generate-id": {
          "description": "Generate hardware ID for offline licensing",
          "parameters": {
            "output": {
              "short": "-o",
              "help": "Output file (default: hardware-id.txt)",
              "required": false
            }
          }
        },
        "request": {
          "description": "Request license using hardware ID",
          "parameters": {
            "hardware-id": {
              "short": "-i",
              "help": "Hardware ID or file containing it",
              "required": true
            },
            "output": {
              "short": "-o",
              "help": "Output file (default: license.lic)",
              "required": false
            },
            "server-url": {
              "short": "-s",
              "help": "License server URL (optional)",
              "required": false
            }
          }
        },
        "install": {
          "description": "Install license file",
          "parameters": {
            "file": {
              "short": "-f",
              "help": "License file to install",
              "required": true
            },
            "target": {
              "short": "-t",
              "help": "Target directory (default: auto-detect)",
              "required": false
            }
          }
        }
      }
    },
    "workflow": {
      "description": "High-level workflow commands",
      "subcommands": {
        "repo-create": {
          "description": "Create and initialize repository on machine",
          "parameters": {
            "team": {
              "help": "Team name",
              "required": true
            },
            "name": {
              "help": "Repository name",
              "required": true
            },
            "machine": {
              "help": "Machine to initialize repository on",
              "required": true
            },
            "size": {
              "help": "Repository size (e.g., 1G, 500M, 10G)",
              "required": true
            },
            "vault": {
              "help": "Repository vault data (JSON)",
              "required": false
            },
            "parent": {
              "help": "Parent repository name",
              "required": false
            },
            "trace": {
              "action": "store_true",
              "help": "Show task ID for tracking",
              "required": false
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 300,
              "help": "Timeout in seconds when waiting (default: 300)",
              "required": false
            }
          }
        },
        "repo-push": {
          "description": "Push repository with automatic destination creation",
          "parameters": {
            "source-team": {
              "help": "Source team name",
              "required": true
            },
            "source-machine": {
              "help": "Source machine name",
              "required": true
            },
            "source-repo": {
              "help": "Source repository name",
              "required": true
            },
            "source-path": {
              "default": "/",
              "help": "Source path within repository (default: /)",
              "required": false
            },
            "dest-team": {
              "help": "Destination team name",
              "required": true
            },
            "dest-repo": {
              "help": "Destination repository name",
              "required": true
            },
            "dest-type": {
              "choices": [
                "machine",
                "storage"
              ],
              "default": "machine",
              "help": "Destination type",
              "required": false
            },
            "dest-machine": {
              "help": "Destination machine name (required for machine destination)",
              "required": false
            },
            "dest-storage": {
              "help": "Destination storage name (required for storage destination)",
              "required": false
            },
            "trace": {
              "action": "store_true",
              "help": "Show task ID for tracking",
              "required": false
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 300,
              "help": "Timeout in seconds when waiting (default: 300)",
              "required": false
            }
          }
        },
        "connectivity-test": {
          "description": "Test connectivity to multiple machines",
          "parameters": {
            "team": {
              "help": "Team name",
              "required": true
            },
            "machines": {
              "nargs": "+",
              "help": "Machine names to test",
              "required": true
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 30,
              "help": "Timeout in seconds per machine when waiting (default: 30)",
              "required": false
            }
          }
        },
        "hello-test": {
          "description": "Execute hello function on machine",
          "parameters": {
            "team": {
              "help": "Team name",
              "required": true
            },
            "machine": {
              "help": "Machine name",
              "required": true
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 30,
              "help": "Timeout in seconds when waiting (default: 30)",
              "required": false
            }
          }
        },
        "ssh-test": {
          "description": "Test SSH connectivity through bridge",
          "parameters": {
            "team": {
              "help": "Team name (required by API)",
              "required": true
            },
            "bridge": {
              "help": "Bridge name",
              "required": true
            },
            "host": {
              "help": "Target host to test",
              "required": true
            },
            "user": {
              "help": "SSH username",
              "required": true
            },
            "password": {
              "help": "SSH password (optional)",
              "required": false
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 30,
              "help": "Timeout in seconds when waiting (default: 30)",
              "required": false
            }
          }
        },
        "machine-setup": {
          "description": "Setup machine with datastore",
          "parameters": {
            "team": {
              "help": "Team name",
              "required": true
            },
            "machine": {
              "help": "Machine name",
              "required": true
            },
            "datastore-size": {
              "default": "default",
              "help": "Datastore size (default: default)",
              "required": false
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for completion",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 300,
              "help": "Timeout in seconds when waiting (default: 300)",
              "required": false
            }
          }
        },
        "add-machine": {
          "description": "Create machine with SSH connection test",
          "parameters": {
            "team": {
              "help": "Team name",
              "required": true
            },
            "name": {
              "help": "Machine name",
              "required": true
            },
            "bridge": {
              "help": "Bridge name",
              "required": true
            },
            "vault": {
              "help": "Machine vault data (JSON) with ip, user, ssh_password, etc.",
              "required": false
            },
            "no-test": {
              "action": "store_true",
              "help": "Skip SSH connection test",
              "required": false
            },
            "auto-setup": {
              "action": "store_true",
              "help": "Automatically run machine setup if SSH test passes",
              "required": false
            },
            "datastore-size": {
              "default": "95%",
              "help": "Datastore size for auto-setup (default: 95%%)",
              "required": false
            },
            "wait": {
              "action": "store_true",
              "help": "Wait for SSH test completion",
              "required": false
            },
            "trace": {
              "action": "store_true",
              "help": "Show task IDs for tracking",
              "required": false
            },
            "poll-interval": {
              "type": "int",
              "default": 2,
              "help": "Polling interval in seconds when waiting (default: 2)",
              "required": false
            },
            "wait-timeout": {
              "type": "int",
              "default": 30,
              "help": "Timeout in seconds when waiting for SSH test (default: 30)",
              "required": false
            }
          }
        }
      }
    },
    "create": {
      "company": [
        {
          "name": "name",
          "help": "Company name"
        },
        {
          "name": "--email",
          "help": "Admin email address"
        },
        {
          "name": "--password",
          "help": "Admin password"
        },
        {
          "name": "--activation-code",
          "help": "Activation code (default: 111111)"
        },
        {
          "name": "--plan",
          "help": "Subscription plan",
          "choices": [
            "COMMUNITY",
            "ADVANCED",
            "PREMIUM",
            "ELITE"
          ]
        }
      ],
      "user": [
        {
          "name": "email",
          "help": "User email address"
        },
        {
          "name": "--password",
          "help": "User password"
        },
        {
          "name": "--activation-code",
          "help": "Activation code (default: 111111)"
        }
      ],
      "team": [
        {
          "name": "name",
          "help": "Team name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "region": [
        {
          "name": "name",
          "help": "Region name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "bridge": [
        {
          "name": "region",
          "help": "Region name"
        },
        {
          "name": "name",
          "help": "Bridge name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "machine": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "bridge",
          "help": "Bridge name"
        },
        {
          "name": "name",
          "help": "Machine name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "repository": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Repository name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "storage": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Storage name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "schedule": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Schedule name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "queue-item": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "machine",
          "help": "Machine name"
        },
        {
          "name": "bridge",
          "help": "Bridge name"
        },
        {
          "name": "--priority",
          "type": "int",
          "default": 3,
          "choices": [
            1,
            2,
            3,
            4,
            5
          ],
          "help": "Priority level (1=highest, 5=lowest, default=3). Premium/Elite subscriptions only."
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ]
    },
    "list": {
      "teams": [],
      "regions": [],
      "users": [],
      "sessions": [],
      "resource-limits": [],
      "subscription": [],
      "bridges": [
        {
          "name": "region",
          "help": "Region name"
        }
      ],
      "data-graph": [],
      "company-vault": [],
      "lookup-data": [
        {
          "name": "--context",
          "help": "Context filter (e.g., machine_create, queue_create)"
        }
      ],
      "user-company": [],
      "audit-logs": [
        {
          "name": "--start-date",
          "help": "Start date for audit logs (ISO format)"
        },
        {
          "name": "--end-date",
          "help": "End date for audit logs (ISO format)"
        },
        {
          "name": "--entity-filter",
          "help": "Filter by entity type (e.g., Team, Machine, User)"
        },
        {
          "name": "--max-records",
          "type": "int",
          "help": "Maximum number of records to retrieve (default: 1000)"
        }
      ],
      "entity-history": [
        {
          "name": "entity_type",
          "help": "Entity type (e.g., Team, Machine, User, Region, Bridge)"
        },
        {
          "name": "credential",
          "help": "Entity credential (GUID)"
        },
        {
          "name": "--max-records",
          "type": "int",
          "help": "Maximum number of records to retrieve (default: 500)"
        }
      ],
      "team-machines": [
        {
          "name": "team",
          "help": "Team name"
        }
      ],
      "team-members": [
        {
          "name": "team",
          "help": "Team name"
        }
      ],
      "team-repositories": [
        {
          "name": "team",
          "help": "Team name"
        }
      ],
      "team-schedules": [
        {
          "name": "team",
          "help": "Team name"
        }
      ],
      "team-storages": [
        {
          "name": "team",
          "help": "Team name"
        }
      ]
    },
    "update": {
      "team": [
        {
          "name": "name",
          "help": "Team name"
        },
        {
          "name": "new_name",
          "help": "New team name"
        }
      ],
      "region": [
        {
          "name": "name",
          "help": "Region name"
        },
        {
          "name": "new_name",
          "help": "New region name"
        }
      ],
      "bridge": [
        {
          "name": "region",
          "help": "Region name"
        },
        {
          "name": "name",
          "help": "Bridge name"
        },
        {
          "name": "new_name",
          "help": "New bridge name"
        }
      ],
      "machine": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Machine name"
        },
        {
          "name": "new_name",
          "help": "New machine name"
        }
      ],
      "machine-bridge": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Machine name"
        },
        {
          "name": "new_bridge",
          "help": "New bridge name"
        }
      ],
      "repository": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Repository name"
        },
        {
          "name": "new_name",
          "help": "New repository name"
        }
      ],
      "storage": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Storage name"
        },
        {
          "name": "new_name",
          "help": "New storage name"
        }
      ],
      "schedule": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Schedule name"
        },
        {
          "name": "new_name",
          "help": "New schedule name"
        }
      ],
      "repository-vault": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Repository name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        },
        {
          "name": "--vault-version",
          "type": "int",
          "help": "Vault version"
        }
      ],
      "storage-vault": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Storage name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        },
        {
          "name": "--vault-version",
          "type": "int",
          "help": "Vault version"
        }
      ],
      "schedule-vault": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Schedule name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        },
        {
          "name": "--vault-version",
          "type": "int",
          "help": "Vault version"
        }
      ],
      "machine-status": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Machine name"
        },
        {
          "name": "status",
          "help": "New status value"
        }
      ]
    },
    "rm": {
      "team": [
        {
          "name": "name",
          "help": "Team name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "machine": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Machine name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "bridge": [
        {
          "name": "region",
          "help": "Region name"
        },
        {
          "name": "name",
          "help": "Bridge name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "region": [
        {
          "name": "name",
          "help": "Region name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "repository": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Repository name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "storage": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Storage name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "schedule": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Schedule name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "queue-item": [
        {
          "name": "task_id",
          "help": "Task ID"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ]
    },
    "permission": {
      "create-group": [
        {
          "name": "name",
          "help": "Permission group name"
        }
      ],
      "delete-group": [
        {
          "name": "name",
          "help": "Permission group name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "add": [
        {
          "name": "group",
          "help": "Permission group name"
        },
        {
          "name": "name",
          "help": "Permission name"
        }
      ],
      "remove": [
        {
          "name": "group",
          "help": "Permission group name"
        },
        {
          "name": "name",
          "help": "Permission name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "assign": [
        {
          "name": "email",
          "help": "User email address"
        },
        {
          "name": "group",
          "help": "Permission group name"
        }
      ],
      "list-groups": [],
      "list-group": [
        {
          "name": "name",
          "help": "Permission group name"
        }
      ]
    },
    "team-member": {
      "add": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "email",
          "help": "User email address"
        }
      ],
      "remove": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "email",
          "help": "User email address"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ]
    },
    "bridge": {
      "reset-auth": [
        {
          "name": "name",
          "help": "Bridge name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ]
    },
    "company": {
      "block-user-requests": [
        {
          "name": "block",
          "help": "Block user requests (true/false)",
          "type": "lambda x: x.lower() == 'true'"
        }
      ],
      "update-vault": [
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        },
        {
          "name": "--vault-version",
          "type": "int",
          "help": "Vault version"
        }
      ],
      "get-vaults": [],
      "update-vaults": [
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "export-data": [],
      "import-data": [
        {
          "name": "--vault",
          "help": "JSON company data to import"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON company data"
        },
        {
          "name": "--import-mode",
          "help": "Import mode: skip or override",
          "choices": [
            "skip",
            "override"
          ],
          "default": "skip"
        }
      ]
    },
    "audit": {
      "trace": [
        {
          "name": "entity_type",
          "help": "Entity type (e.g., Team, Machine, User, Region, Bridge)"
        },
        {
          "name": "credential",
          "help": "Entity credential (GUID)"
        },
        {
          "name": "--max-records",
          "type": "int",
          "help": "Maximum number of records to retrieve"
        }
      ]
    },
    "inspect": {
      "machine": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Machine name"
        }
      ],
      "repository": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Repository name"
        }
      ]
    },
    "distributed-storage": {
      "create-cluster": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Cluster name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        }
      ],
      "delete-cluster": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Cluster name"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "get-cluster": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "name",
          "help": "Cluster name"
        }
      ],
      "list-clusters": [
        {
          "name": "team",
          "help": "Team name"
        }
      ],
      "add-machines": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "cluster",
          "help": "Cluster name"
        },
        {
          "name": "machines",
          "help": "Comma-separated list of machine names"
        }
      ],
      "remove-machines": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "cluster",
          "help": "Cluster name"
        },
        {
          "name": "machines",
          "help": "Comma-separated list of machine names"
        },
        {
          "name": "--force",
          "action": "store_true",
          "help": "Skip confirmation"
        }
      ],
      "update-status": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "cluster",
          "help": "Cluster name"
        },
        {
          "name": "status",
          "help": "New status value"
        }
      ],
      "update-vault": [
        {
          "name": "team",
          "help": "Team name"
        },
        {
          "name": "cluster",
          "help": "Cluster name"
        },
        {
          "name": "--vault",
          "help": "JSON vault data"
        },
        {
          "name": "--vault-file",
          "help": "File containing JSON vault data"
        },
        {
          "name": "--vault-version",
          "type": "int",
          "help": "Vault version (default: 1)"
        }
      ]
    },
    "auth": {
      "status": [
        {
          "name": "request_hash",
          "help": "Request hash to check status for"
        }
      ],
      "privilege": [
        {
          "name": "request_hash",
          "help": "Request hash to privilege"
        },
        {
          "name": "privilege",
          "help": "Privilege level to grant"
        }
      ]
    }
  },
  "QUEUE_FUNCTIONS": {
    "os_setup": {
      "description": "Setup operating system with required tools and configurations",
      "params": {
        "datastore_size": {
          "type": "string",
          "default": "95%",
          "help": "Datastore size (e.g., 95%, 100G)"
        },
        "source": {
          "type": "string",
          "default": "apt-repo",
          "help": "Package source"
        }
      }
    },
    "hello": {
      "description": "Simple test function that prints hello from hostname",
      "params": {}
    },
    "uninstall": {
      "description": "Cleanup and uninstall system components",
      "params": {}
    },
    "repo_new": {
      "description": "Create a new repository",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name"
        },
        "size": {
          "type": "string",
          "required": true,
          "help": "Repository size (e.g., 10G)"
        }
      }
    },
    "repo_mount": {
      "description": "Mount repository filesystems",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        },
        "from": {
          "type": "string",
          "help": "Remote machine to mount from"
        }
      }
    },
    "repo_unmount": {
      "description": "Unmount repository filesystems",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        },
        "from": {
          "type": "string",
          "help": "Remote machine to unmount from"
        }
      }
    },
    "repo_up": {
      "description": "Start repository services using Rediaccfile",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        },
        "option": {
          "type": "string",
          "help": "Options (e.g., prep-only)"
        }
      }
    },
    "repo_down": {
      "description": "Stop repository services",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        }
      }
    },
    "repo_resize": {
      "description": "Resize repository storage",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name"
        },
        "size": {
          "type": "string",
          "required": true,
          "help": "New size (e.g., 20G)"
        }
      }
    },
    "repo_rm": {
      "description": "Delete repository",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name"
        }
      }
    },
    "repo_ownership": {
      "description": "Change repository ownership",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name"
        },
        "from": {
          "type": "string",
          "required": true,
          "help": "Current owner"
        },
        "to": {
          "type": "string",
          "help": "New owner (default: universal user)"
        }
      }
    },
    "list_system": {
      "description": "List repositories",
      "params": {
        "kind": {
          "type": "string",
          "default": "repo",
          "help": "Type to list"
        },
        "format": {
          "type": "string",
          "help": "Output format (json)"
        }
      }
    },
    "repo_push": {
      "description": "Push repository to remote storage",
      "params": {
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        },
        "dest": {
          "type": "string",
          "required": true,
          "help": "Destination filename"
        },
        "to": {
          "type": "string",
          "help": "Destination machine/storage"
        },
        "state": {
          "type": "string",
          "help": "Required repository state (online/offline)"
        },
        "option": {
          "type": "string",
          "help": "Options (e.g., override)"
        }
      }
    },
    "repo_pull": {
      "description": "Pull repository from remote storage",
      "params": {
        "from": {
          "type": "string",
          "required": true,
          "help": "Source machine/storage"
        },
        "repo": {
          "type": "string",
          "required": true,
          "help": "Repository name(s), comma-separated"
        }
      }
    }
  },
  "METADATA": {
    "version": "2.0.0",
    "reorganized": "2025-01-15T00:00:00Z",
    "description": "Reorganized structure separating generated API endpoints from manual CLI commands",
    "sections": {
      "API_ENDPOINTS": {
        "description": "Generated from stored-procedures.json via proc.sh synchronization",
        "source": "database stored procedures",
        "last_sync": null,
        "modification_allowed": false
      },
      "CLI_COMMANDS": {
        "description": "Manually defined CLI commands with their complete configuration",
        "source": "manual configuration",
        "modification_allowed": true
      },
      "QUEUE_FUNCTIONS": {
        "description": "Queue function definitions for bash script operations",
        "source": "manual configuration",
        "modification_allowed": true
      }
    }
  }
}
