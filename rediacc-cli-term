#!/usr/bin/env python3
"""
Rediacc CLI Terminal - Interactive terminal access to Rediacc repository Docker environments
Establishes SSH connection with proper Docker environment variables and socket access
"""
import argparse
import subprocess
import sys

# Import common functionality from core module
from rediacc_cli_core import (
    colorize,
    validate_cli_tool,
    RepositoryConnection,
    INTERIM_FOLDER_NAME
)


def connect_to_terminal(args):
    """Connect to repository terminal via SSH"""
    print(colorize(f"Connecting to repository '{args.repo}' on machine '{args.machine}'...", 'HEADER'))
    
    # Create repository connection
    conn = RepositoryConnection(args.token, args.machine, args.repo)
    conn.connect()
    
    # Set up SSH
    ssh_opts, ssh_key_file, known_hosts_file = conn.setup_ssh()
    
    try:
        # Build environment variables for the repository using paths from connection
        docker_folder = conn.repo_paths['docker_folder']
        docker_socket = conn.repo_paths['docker_socket']
        docker_host = f"unix://{docker_socket}"
        repo_mount_path = conn.repo_paths['mount_path']
        
        # Build SSH command with environment setup
        if args.command:
            # For command execution, minimal setup
            ssh_env_setup = f"""
export REPO_PATH='{repo_mount_path}'
export DOCKER_HOST='{docker_host}'
export DOCKER_FOLDER='{docker_folder}'
export DOCKER_SOCKET='{docker_socket}'
export DOCKER_DATA='{conn.repo_paths['docker_data']}'
export DOCKER_EXEC='{conn.repo_paths['docker_exec']}'
cd "$REPO_PATH" 2>/dev/null
"""
        else:
            # For interactive session, full setup with welcome message
            ssh_env_setup = f"""
export REPO_PATH='{repo_mount_path}'
export DOCKER_HOST='{docker_host}'
export DOCKER_FOLDER='{docker_folder}'
export DOCKER_SOCKET='{docker_socket}'
export DOCKER_DATA='{conn.repo_paths['docker_data']}'
export DOCKER_EXEC='{conn.repo_paths['docker_exec']}'
export PS1='\\[\\033[01;32m\\][\\u@{args.repo}\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]]\\$ '
cd "$REPO_PATH" 2>/dev/null || echo "Warning: Repository not mounted at $REPO_PATH"

# Define helper functions
enter_container() {{
    local container="${{1:-}}"
    if [ -z "$container" ]; then
        echo "Usage: enter_container <container_name_or_id>"
        echo "Available containers:"
        docker ps --format "table {{{{.Names}}}}\\t{{{{.Image}}}}\\t{{{{.Status}}}}"
        return 1
    fi
    docker exec -it "$container" bash || docker exec -it "$container" sh
}}

logs() {{
    local container="${{1:-}}"
    local lines="${{2:-50}}"
    if [ -z "$container" ]; then
        echo "Usage: logs <container_name_or_id> [lines]"
        echo "Available containers:"
        docker ps -a --format "table {{{{.Names}}}}\\t{{{{.Status}}}}"
        return 1
    fi
    docker logs --tail "$lines" -f "$container"
}}

status() {{
    echo -e '\\033[1;36m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\033[0m'
    echo -e '\\033[1;32mRepository Status\\033[0m'
    echo -e '\\033[1;36m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\033[0m'
    echo -e "\\n\\033[1;34mDocker Status:\\033[0m"
    if docker version >/dev/null 2>&1; then
        echo "  ✓ Docker daemon is running"
        docker ps -q | wc -l | xargs -I {{}} echo "  • {{}} containers running"
    else
        echo "  ✗ Docker daemon is not accessible"
    fi
    echo -e "\\n\\033[1;34mRepository Files:\\033[0m"
    ls -la "$REPO_PATH" 2>/dev/null | tail -n +2 | head -10
    echo ""
}}

# Export functions
export -f enter_container
export -f logs
export -f status

clear
echo -e '\\033[1;36m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\033[0m'
echo -e '\\033[1;32mConnected to Rediacc Repository:\\033[0m \\033[1;33m{args.repo}\\033[0m'
echo -e '\\033[1;36m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\033[0m'
echo ""
echo -e '\\033[1;34mRepository Path:\\033[0m $REPO_PATH'
echo -e '\\033[1;34mDocker Socket:\\033[0m   $DOCKER_SOCKET'
echo ""
echo -e '\\033[1;33mQuick Commands:\\033[0m'
echo "  • status                       - Show repository status"
echo "  • enter_container <name>       - Enter a container"
echo "  • logs <name>                  - View container logs"
echo "  • docker ps                    - List running containers"
echo ""
echo -e '\\033[1;36m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\033[0m'
echo ""
"""
        
        # Get universal user for sudo
        universal_user = conn.connection_info.get('universal_user', 'rediacc')
        
        # Prepare the SSH command
        ssh_cmd = [
            'ssh',
            '-tt',  # Force pseudo-terminal allocation even if stdin is not a terminal
        ] + ssh_opts.split() + [
            conn.ssh_destination
        ]
        
        if args.command:
            # If a command is provided, execute it instead of interactive shell
            # Escape the environment setup and command properly
            full_command = ssh_env_setup.replace("'", "'\"'\"'") + args.command
            ssh_cmd.append(f"sudo -u {universal_user} bash -c '{full_command}'")
            print(colorize(f"Executing command: {args.command}", 'BLUE'))
        else:
            # Interactive shell
            print(colorize("Opening interactive terminal...", 'BLUE'))
            print(colorize("Type 'exit' to disconnect.", 'YELLOW'))
            full_command = ssh_env_setup.replace("'", "'\"'\"'") + "exec bash -l"
            ssh_cmd.append(f"sudo -u {universal_user} bash -c '{full_command}'")
        
        # Execute SSH connection
        result = subprocess.run(ssh_cmd)
        
        if result.returncode != 0:
            print(colorize(f"\nDisconnected from repository terminal (exit code: {result.returncode})", 'YELLOW'))
        else:
            print(colorize("\nDisconnected from repository terminal.", 'GREEN'))
            
    finally:
        # Clean up SSH key and known_hosts files
        conn.cleanup_ssh(ssh_key_file, known_hosts_file)

def main():
    parser = argparse.ArgumentParser(
        description='Rediacc CLI Terminal - Interactive terminal access to repository Docker environments',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Connect to repository terminal:
    %(prog)s --token=<GUID> --machine=server1 --repo=myrepo
    
  Execute a command in repository environment:
    %(prog)s --token=<GUID> --machine=server1 --repo=myrepo --command="docker ps"
    
  Enter a specific container:
    %(prog)s --token=<GUID> --machine=server1 --repo=myrepo --command="docker exec -it mycontainer bash"
    
  Check Docker status:
    %(prog)s --token=<GUID> --machine=server1 --repo=myrepo --command="docker stats --no-stream"

Environment Variables Set:
  REPO_PATH       - Repository mount path
  DOCKER_HOST     - Repository's Docker socket
  DOCKER_FOLDER   - Docker configuration folder
  DOCKER_SOCKET   - Docker socket path
  DOCKER_DATA     - Docker data directory
  DOCKER_EXEC     - Docker exec directory
"""
    )
    
    parser.add_argument('--token', required=True, help='Authentication token (GUID)')
    parser.add_argument('--machine', required=True, help='Target machine name')
    parser.add_argument('--repo', required=True, help='Target repository name')
    parser.add_argument('--command', help='Command to execute (interactive shell if not specified)')
    
    args = parser.parse_args()
    
    # Validate CLI tool exists
    validate_cli_tool()
    
    # Connect to terminal
    connect_to_terminal(args)

if __name__ == '__main__':
    main()