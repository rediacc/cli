#!/bin/bash
# Universal Rediacc CLI wrapper for Linux/macOS
# Consolidated wrapper with all CLI, Desktop, and Docker functionality

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
CLI_ROOT="$SCRIPT_DIR"

# Load environment variables from .env file if it exists
ENV_FILE="$SCRIPT_DIR/../.env"
if [ -f "$ENV_FILE" ]; then
    # Export variables, removing quotes
    set -a
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        
        # Remove surrounding quotes from value
        value="${value%\"}"
        value="${value#\"}"
        value="${value%\'}"
        value="${value#\'}"
        
        # Export the variable
        export "$key=$value"
    done < "$ENV_FILE"
    set +a
fi

# Note: Environment variables can be set externally if needed
# Default values are defined in the Python code

# Helper functions
find_python() {
    # Check if we're in MSYS2 and should use MinGW64 Python
    if [ -n "$MSYSTEM" ] && [ -x "/mingw64/bin/python3" ]; then
        echo "/mingw64/bin/python3"
        return 0
    fi
    
    # Try different Python commands in order of preference
    for cmd in python3 python; do
        if command -v "$cmd" &> /dev/null; then
            if "$cmd" --version 2>&1 | grep -q "Python [0-9]"; then
                echo "$cmd"
                return 0
            fi
        fi
    done
    return 1
}

install_python_packages() {
    local python_cmd="$1"
    local requirements_file="$CLI_ROOT/requirements.txt"
    
    if [ ! -f "$requirements_file" ]; then
        echo -e "${YELLOW}Warning: requirements.txt not found, skipping package installation${NC}"
        return 0
    fi
    
    echo -e "${CYAN}Installing Python packages from requirements.txt...${NC}"
    
    # Upgrade pip first
    if ! "$python_cmd" -m pip install --upgrade pip --quiet; then
        echo -e "${YELLOW}Warning: Failed to upgrade pip${NC}"
    fi
    
    # Install requirements
    if "$python_cmd" -m pip install -r "$requirements_file" --quiet; then
        echo -e "${GREEN}✓ Python packages installed successfully${NC}"
    else
        echo -e "${YELLOW}Warning: Some Python packages may not have installed correctly${NC}"
    fi
}

get_python_command() {
    # Return the detected Python command, or exit with error
    if python_cmd=$(find_python); then
        echo "$python_cmd"
    else
        echo -e "${RED}Error: Python not found. Run: ./rediacc setup${NC}" >&2
        exit 1
    fi
}

# Get Python command once at the start
PYTHON_CMD=$(get_python_command)

# Check for --verbose flag in arguments
VERBOSE_MODE=""
for arg in "$@"; do
    if [ "$arg" = "--verbose" ] || [ "$arg" = "-v" ]; then
        VERBOSE_MODE="1"
        export REDIACC_VERBOSE=1
        break
    fi
done

# Debug: Show which Python is being used (only if REDIACC_DEBUG or verbose mode is set)
if [ -n "$REDIACC_DEBUG" ] || [ -n "$VERBOSE_MODE" ]; then
    echo -e "${CYAN}[DEBUG] Using Python: $PYTHON_CMD${NC}" >&2
fi

print_help() {
    # Use dynamic Python help system (DRY - delegates to show_help() in cli_main.py)
    "$PYTHON_CMD" "$CLI_ROOT/src/cli/core/format_help.py"
}

print_version() {
    # Use Python version system (DRY - delegates to show_version() in cli_main.py)
    "$PYTHON_CMD" -c "import sys; sys.path.insert(0, '$CLI_ROOT/src'); from cli.commands.cli_main import show_version; show_version()"
}

# Setup function
setup() {
    echo -e "${CYAN}=== Rediacc CLI Setup ===${NC}"
    echo

    # Check Python
    if python_cmd=$(find_python); then
        python_version=$("$python_cmd" -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')
        echo -e "${GREEN}✓ Python $python_version found ($python_cmd)${NC}"

        # Install Python packages
        install_python_packages "$python_cmd"
    else
        echo -e "${RED}Error: Python is not installed${NC}"
        echo "Please install Python 3.7 or later"
        exit 1
    fi

    # Check rsync
    if ! command -v rsync &> /dev/null; then
        echo -e "${YELLOW}Warning: rsync not found${NC}"
        echo "Install rsync for file synchronization support:"
        echo "  Ubuntu/Debian: sudo apt-get install rsync"
        echo "  macOS: brew install rsync"
    else
        echo -e "${GREEN}✓ rsync found${NC}"
    fi

    # Check SSH
    if ! command -v ssh &> /dev/null; then
        echo -e "${YELLOW}Warning: SSH not found${NC}"
        echo "SSH is required for terminal access"
    else
        echo -e "${GREEN}✓ SSH found${NC}"
    fi

    # Check tkinter for desktop application
    if "$python_cmd" -c "import tkinter" 2>/dev/null; then
        echo -e "${GREEN}✓ tkinter found (desktop app support available)${NC}"
    else
        echo -e "${YELLOW}Warning: tkinter not found${NC}"
        echo "Install python3-tk for Rediacc Desktop application support:"
        echo "  Ubuntu/Debian: sudo apt-get install python3-tk"
        echo "  macOS: tkinter should be included with Python"
    fi

    # Check configuration
    if [ -f "$CLI_ROOT/.env" ]; then
        echo -e "${GREEN}✓ Configuration file found${NC}"
    else
        echo -e "${YELLOW}Warning: No .env file found${NC}"
        echo "Copy .env.example to .env and configure:"
        echo "  cp .env.example .env"
    fi

    # Register protocol handler
    echo
    echo -e "${CYAN}Registering rediacc:// protocol handler...${NC}"
    if "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" protocol register; then
        echo -e "${GREEN}✓ Protocol handler registered successfully${NC}"
        echo -e "${YELLOW}Note: You may need to restart your browser${NC}"
    else
        echo -e "${YELLOW}Warning: Protocol registration failed${NC}"
        echo "You can register it manually later with: rediacc protocol register"
    fi

    echo
    echo -e "${GREEN}Setup complete!${NC}"
    echo "Try: rediacc --version"
}

# Test function
test_cli() {
    # Change to CLI root
    cd "$CLI_ROOT"
    
    # Check for specific test type
    case "$1" in
        desktop)
            echo -e "${GREEN}Running desktop application tests...${NC}"
            shift
            python3 -m pytest tests/gui/ -v "$@"
            ;;
        workflow)
            echo -e "${GREEN}Running workflow tests...${NC}"
            shift
            python3 -m pytest tests/workflow/ -v "$@"
            ;;
        yaml)
            echo -e "${GREEN}Running YAML tests...${NC}"
            shift
            python3 tests/run_tests.py "$@"
            ;;
        "")
            echo -e "${GREEN}Running all CLI tests...${NC}"
            # Run all tests
            python3 -m pytest tests/ -v
            ;;
        *)
            echo -e "${GREEN}Running CLI tests with options...${NC}"
            # Pass arguments to pytest
            python3 -m pytest tests/ "$@"
            ;;
    esac
}

# Release function
release() {
    echo -e "${GREEN}Preparing CLI release...${NC}"
    
    # Create release directory
    release_dir="$CLI_ROOT/release"
    rm -rf "$release_dir"
    mkdir -p "$release_dir"
    
    # Copy essential files
    cp -r "$CLI_ROOT/src" "$release_dir/"
    cp "$CLI_ROOT/rediacc" "$release_dir/"
    cp "$CLI_ROOT/rediacc.bat" "$release_dir/" 2>/dev/null || true
    cp "$CLI_ROOT/.env.example" "$release_dir/"
    cp "$CLI_ROOT/requirements.txt" "$release_dir/" 2>/dev/null || true
    
    # Create version info
    version=$(date +%Y.%m.%d.%H%M)
    echo "{\"version\": \"$version\", \"build_date\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > "$release_dir/version.json"
    
    # Create tarball
    tar -czf "rediacc-$version.tar.gz" -C "$CLI_ROOT" release/
    
    echo -e "${GREEN}Release created: rediacc-$version.tar.gz${NC}"
    echo "Release directory: $release_dir"
}

# Docker functions
docker_build() {
    echo -e "${GREEN}Building CLI Docker image...${NC}"
    
    docker build -t rediacc:latest \
        --build-arg REDIACC_LINUX_USER=rediacc \
        --build-arg REDIACC_LINUX_GROUP=rediacc \
        --build-arg REDIACC_USER_UID=7111 \
        --build-arg REDIACC_USER_GID=7111 \
        -f "$CLI_ROOT/docker/Dockerfile" \
        "$CLI_ROOT"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Docker image built successfully: rediacc:latest${NC}"
    else
        echo -e "${RED}Docker build failed${NC}"
        return 1
    fi
}

docker_run() {
    # Build if image doesn't exist
    if ! docker images | grep -q "rediacc.*latest"; then
        echo -e "${YELLOW}Docker image not found. Building...${NC}"
        docker_build || return 1
    fi
    
    # Run with environment file if it exists
    env_file_arg=""
    if [ -f "$CLI_ROOT/.env" ]; then
        env_file_arg="--env-file $CLI_ROOT/.env"
    fi
    
    docker run -it --rm \
        --name rediacc-run-$$ \
        $env_file_arg \
        -v "$CLI_ROOT/.config:/home/rediacc/.config" \
        -v "$HOME/.ssh:/home/rediacc/.ssh:ro" \
        -v "$PWD:/workspace" \
        -w /workspace \
        --network host \
        rediacc:latest \
        "$@"
}

docker_shell() {
    echo -e "${GREEN}Starting interactive shell in Docker...${NC}"
    
    # Build if image doesn't exist
    if ! docker images | grep -q "rediacc.*latest"; then
        echo -e "${YELLOW}Docker image not found. Building...${NC}"
        docker_build || return 1
    fi
    
    # Run with environment file if it exists
    env_file_arg=""
    if [ -f "$CLI_ROOT/.env" ]; then
        env_file_arg="--env-file $CLI_ROOT/.env"
    fi
    
    docker run -it --rm \
        --name rediacc-shell-$$ \
        $env_file_arg \
        -v "$CLI_ROOT/.config:/home/rediacc/.config" \
        -v "$HOME/.ssh:/home/rediacc/.ssh:ro" \
        -v "$PWD:/workspace" \
        -w /workspace \
        --network host \
        rediacc:latest \
        /bin/bash
}


# Desktop application functions
desktop() {
    echo -e "${GREEN}Starting Rediacc Desktop application...${NC}"
    
    # Check Python
    if ! command -v python3 &> /dev/null; then
        echo -e "${RED}Error: Python 3 is not installed${NC}"
        return 1
    fi
    
    # Check tkinter
    if ! python3 -c "import tkinter" 2>/dev/null; then
        echo -e "${RED}Error: tkinter not found${NC}"
        echo "Install python3-tk:"
        echo "  Ubuntu/Debian: sudo apt-get install python3-tk"
        echo "  Fedora/RHEL: sudo dnf install python3-tkinter"
        echo "  macOS: tkinter should be included with Python"
        return 1
    fi
    
    # Run Desktop GUI directly
    "$PYTHON_CMD" "$CLI_ROOT/src/cli/gui/main.py" "$@"
}

desktop_docker_build() {
    echo -e "${GREEN}Building Rediacc Desktop Docker image...${NC}"
    
    # Check if base image exists
    if ! docker images | grep -q "rediacc/cli.*latest"; then
        echo -e "${YELLOW}Base image not found. Building base image first...${NC}"
        docker build -t rediacc/cli:latest \
            --build-arg REDIACC_LINUX_USER=rediacc \
            --build-arg REDIACC_LINUX_GROUP=rediacc \
            --build-arg REDIACC_USER_UID=7111 \
            --build-arg REDIACC_USER_GID=7111 \
            -f "$CLI_ROOT/docker/Dockerfile" \
            "$CLI_ROOT"
        
        if [ $? -ne 0 ]; then
            echo -e "${RED}Base image build failed${NC}"
            return 1
        fi
    fi
    
    # Build CLI image (includes GUI support)
    docker build -t rediacc/cli:latest \
        --build-arg REDIACC_LINUX_USER=rediacc \
        --build-arg REDIACC_LINUX_GROUP=rediacc \
        --build-arg REDIACC_USER_UID=7111 \
        --build-arg REDIACC_USER_GID=7111 \
        -f "$CLI_ROOT/docker/Dockerfile" \
        "$CLI_ROOT"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Docker image built successfully: rediacc/cli:latest${NC}"
    else
        echo -e "${RED}Docker build failed${NC}"
        return 1
    fi
}

desktop_docker() {
    echo -e "${GREEN}Running Rediacc Desktop in Docker...${NC}"
    
    # Check if image exists
    IMAGE_EXISTS=$(docker images -q rediacc/cli:latest 2>/dev/null)
    
    # Check if rebuild is needed
    REBUILD_NEEDED=false
    
    if [ -z "$IMAGE_EXISTS" ]; then
        echo -e "${YELLOW}Docker image not found. Building...${NC}"
        REBUILD_NEEDED=true
    else
        # Check if source files are newer than image
        if [ -f "$CLI_ROOT/.dockerbuild" ]; then
            # Find if any source files are newer than our build marker
            NEWER_FILES=$(find "$CLI_ROOT/src" "$CLI_ROOT/docker" -type f \( -name "*.py" -o -name "Dockerfile*" \) -newer "$CLI_ROOT/.dockerbuild" 2>/dev/null | head -1)
            
            if [ -n "$NEWER_FILES" ]; then
                echo -e "${YELLOW}Source files have been updated. Rebuilding...${NC}"
                REBUILD_NEEDED=true
            else
                echo -e "${GREEN}Docker image is up to date${NC}"
            fi
        else
            # No build marker, so this is an old image or manual build
            echo -e "${YELLOW}No build marker found. Rebuilding to ensure latest version...${NC}"
            REBUILD_NEEDED=true
        fi
    fi
    
    # Build if needed
    if [ "$REBUILD_NEEDED" = true ]; then
        desktop_docker_build || return 1
        # Create/update build marker
        touch "$CLI_ROOT/.dockerbuild"
    fi
    
    # Platform-specific display setup
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        if ! command -v xhost &> /dev/null; then
            echo -e "${RED}XQuartz not found${NC}"
            echo "Install XQuartz from: https://www.xquartz.org/"
            return 1
        fi
        xhost +local:docker 2>/dev/null
        DISPLAY_ENV="-e DISPLAY=host.docker.internal:0"
    else
        # Linux
        xhost +local:docker 2>/dev/null || true
        DISPLAY_ENV="-e DISPLAY=$DISPLAY"
    fi
    
    # Run with desktop application support
    echo -e "${CYAN}Starting desktop application container...${NC}"
    
    # Check if we're in a terminal
    if [ -t 0 ] && [ -t 1 ]; then
        DOCKER_TTY="-it"
    else
        DOCKER_TTY="-i"
        echo -e "${YELLOW}Warning: Not running in interactive terminal${NC}"
    fi
    
    # Ensure .config directory exists
    mkdir -p "$CLI_ROOT/.config"
    
    # Create a temporary directory for container's .config if needed
    REDIACC_VOLUME="$HOME/.config-docker"
    mkdir -p "$REDIACC_VOLUME"
    
    # Copy existing config if it exists
    if [ -f "$CLI_ROOT/.config/config.json" ]; then
        cp "$CLI_ROOT/.config/config.json" "$REDIACC_VOLUME/" 2>/dev/null || true
    fi
    
    # Set permissions for container user (UID 111)
    chmod 777 "$REDIACC_VOLUME" 2>/dev/null || true
    
    docker run $DOCKER_TTY --rm \
        --name rediacc-desktop-$$ \
        $DISPLAY_ENV \
        -v /tmp/.X11-unix:/tmp/.X11-unix:rw \
        -v "$HOME/.Xauthority:/home/rediacc/.Xauthority:ro" \
        -v "$REDIACC_VOLUME:/home/rediacc/.config:rw" \
        -v "$CLI_ROOT/.env:/app/.env:ro" \
        --network host \
        rediacc/cli:latest \
        python3 /app/src/cli/gui/main.py
    
    # Copy config back if it was updated
    if [ -f "$REDIACC_VOLUME/config.json" ]; then
        cp "$REDIACC_VOLUME/config.json" "$CLI_ROOT/.config/" 2>/dev/null || true
    fi
}

# Main command handler
case "$1" in
    setup)
        shift
        setup "$@"
        ;;
        
    test)
        shift
        test_cli "$@"
        ;;
        
    release)
        shift
        release "$@"
        ;;
        
    license)
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/license_main.py" "$@"
        ;;

    login)
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" login "$@"
        ;;
        
    sync)
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/sync_main.py" "$@"
        ;;
        
    term|terminal)
        shift
        # Don't inject token - let the term command manage its own token from config
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/term_main.py" "$@"
        ;;
        
    plugin)
        shift
        # Don't inject token - let the plugin command manage its own token from config
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/plugin_main.py" "$@"
        ;;

    protocol)
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/protocol_main.py" "$@"
        ;;

    compose)
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/compose_main.py" "$@"
        ;;

    desktop|--gui)
        shift
        # Check if next argument is a mode
        if [ "$1" = "docker" ]; then
            shift
            desktop_docker "$@"
        elif [ "$1" = "docker-build" ]; then
            shift
            desktop_docker_build "$@"
        else
            # Default to native mode
            desktop "$@"
        fi
        ;;
        
    docker-build)
        shift
        docker_build "$@"
        ;;
        
    docker-run)
        shift
        docker_run "$@"
        ;;
        
    docker-shell)
        shift
        docker_shell "$@"
        ;;
        
    desktop-docker-build)
        shift
        desktop_docker_build "$@"
        ;;
        
    desktop-docker)
        shift
        desktop_docker "$@"
        ;;
        
    cli)
        # Direct pass-through to CLI without token injection
        shift
        "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" "$@"
        ;;
        
    version|--version)
        # Show version (DRY - uses show_version() function)
        print_version
        ;;
        
    help|--help|-h)
        print_help
        ;;
        
    "")
        # When no arguments provided, show comprehensive help
        print_help
        ;;
        
    *)
        # Pass through to main CLI with token injection if needed
        if [[ ! " $@ " =~ " --token " ]]; then
            token=$(python3 -c "import sys; sys.path.insert(0, '$CLI_ROOT/src'); from cli.core.config import TokenManager; print(TokenManager().get_token() or '')" 2>/dev/null || true)
            if [ -n "$token" ]; then
                "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" --token "$token" "$@"
            else
                "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" "$@"
            fi
        else
            "$PYTHON_CMD" "$CLI_ROOT/src/cli/commands/cli_main.py" "$@"
        fi
        ;;
esac